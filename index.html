<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>æ–‡ä»¶æ‹ç…§è½‰ PDFï¼ˆè‡ªå‹•è£åˆ‡ï¼‹å¼·åŒ–å°æ¯”ï¼‰</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 2em; }
    .preview { display: flex; flex-wrap: wrap; gap: 10px; margin: 1em 0; }
    .preview-item { position: relative; }
    .preview-item img { width: 120px; border: 1px solid #aaa; border-radius: 4px; }
    .remove-btn {
      position: absolute; top: 2px; right: 2px;
      background: rgba(255,0,0,0.8); color: #fff; border: none; border-radius: 3px;
      cursor: pointer; font-size: 12px; padding: 2px 6px;
    }
    .actions { margin-bottom: 1em; }
    button { font-size: 1em; margin-right: .5em; }
    #loading { display:none; color: #009; font-weight: bold; }
  </style>
  <script async src="https://docs.opencv.org/4.x/opencv.js" type="text/javascript"></script>
</head>
<body>
  <h2>ğŸ“„ æ–‡ä»¶æ‹ç…§è½‰ PDFï¼ˆè‡ªå‹•è£åˆ‡ï¼‹å¼·åŒ–å°æ¯”ï¼‰</h2>
  <div class="actions">
    <input type="file" accept="image/*" capture="environment" id="cameraInput" style="display:none">
    <input type="file" accept="image/*" multiple id="fileInput" style="display:none">
    <button onclick="document.getElementById('cameraInput').click()">ğŸ“· æ‹ç…§</button>
    <button onclick="document.getElementById('fileInput').click()">ğŸ–¼ï¸ é¸ç…§ç‰‡</button>
    <button onclick="generatePDF()">ğŸ§¾ ç”¢ç”Ÿ PDF</button>
    <span id="loading">åœ–ç‰‡è™•ç†ä¸­ï¼Œè«‹ç¨å€™...</span>
  </div>
  <div class="preview" id="preview"></div>

  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
  <script>
    const { jsPDF } = window.jspdf;
    let images = [];
    let cvReady = false;

    // ç­‰å¾… OpenCV è¼‰å…¥
    function onOpenCvReady() {
      cvReady = true;
    }
    window.Module = { onRuntimeInitialized: onOpenCvReady };

    // å·¥å…·ï¼šæ’åºå››é‚Šå½¢é»ï¼ˆå·¦ä¸Šã€å³ä¸Šã€å³ä¸‹ã€å·¦ä¸‹ï¼‰
    function sortCorners(pts) {
      // å…ˆæŒ‰yæ’åºï¼ˆä¸Šé¢å…©å€‹ï¼Œä¸‹é¢å…©å€‹ï¼‰
      pts.sort((a, b) => a.y - b.y);
      let top = pts.slice(0, 2).sort((a, b) => a.x - b.x); // å·¦ä¸Šã€å³ä¸Š
      let bottom = pts.slice(2, 4).sort((a, b) => a.x - b.x); // å·¦ä¸‹ã€å³ä¸‹
      return [top[0], top[1], bottom[1], bottom[0]]; // å·¦ä¸Šã€å³ä¸Šã€å³ä¸‹ã€å·¦ä¸‹
    }

    // è‡ªå‹•è£åˆ‡ã€å¼·åŒ–å°æ¯”
    async function processImageAutoCropAndEnhance(img) {
      return new Promise((resolve) => {
        const canvas = document.createElement('canvas');
        canvas.width = img.naturalWidth || img.width;
        canvas.height = img.naturalHeight || img.height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

        let src = cv.imread(canvas);
        let dst = new cv.Mat();
        let gray = new cv.Mat();
        let blurred = new cv.Mat();
        let edged = new cv.Mat();

        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
        cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0);

        // é‚Šç·£åµæ¸¬
        cv.Canny(blurred, edged, 50, 160);

        let contours = new cv.MatVector();
        let hierarchy = new cv.Mat();
        cv.findContours(edged, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);

        // æ‰¾æœ€å¤§ã€å››é»çš„è¼ªå»“
        let maxArea = 0, pageContour = null;
        for (let i = 0; i < contours.size(); i++) {
          let cnt = contours.get(i);
          let peri = cv.arcLength(cnt, true);
          let approx = new cv.Mat();
          cv.approxPolyDP(cnt, approx, 0.02 * peri, true);
          if (approx.rows === 4) {
            let area = cv.contourArea(cnt);
            if (area > maxArea && area > (src.cols*src.rows/8)) {
              maxArea = area;
              if (pageContour) pageContour.delete();
              pageContour = approx;
            } else {
              approx.delete();
            }
          } else {
            approx.delete();
          }
          cnt.delete();
        }

        let resultCanvas = document.createElement('canvas');

        if (pageContour) {
          let pts = [];
          for (let i = 0; i < 4; i++) {
            pts.push({
              x: pageContour.intPtr(i, 0)[0],
              y: pageContour.intPtr(i, 0)[1]
            });
          }
          let [tl, tr, br, bl] = sortCorners(pts);

          let widthA = Math.hypot(br.x - bl.x, br.y - bl.y);
          let widthB = Math.hypot(tr.x - tl.x, tr.y - tl.y);
          let maxWidth = Math.max(widthA, widthB);

          let heightA = Math.hypot(tr.x - br.x, tr.y - br.y);
          let heightB = Math.hypot(tl.x - bl.x, tl.y - bl.y);
          let maxHeight = Math.max(heightA, heightB);

          maxWidth = Math.max(maxWidth, 100);
          maxHeight = Math.max(maxHeight, 100);

          let srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
            tl.x, tl.y, tr.x, tr.y, br.x, br.y, bl.x, bl.y
          ]);
          let dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
            0, 0,
            maxWidth - 1, 0,
            maxWidth - 1, maxHeight - 1,
            0, maxHeight - 1
          ]);
          let M = cv.getPerspectiveTransform(srcTri, dstTri);

          let warped = new cv.Mat();
          cv.warpPerspective(gray, warped, M, new cv.Size(maxWidth, maxHeight), cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());

          // å¼·åŒ–å°æ¯”ï¼ˆäºŒå€¼åŒ–ï¼‰
          cv.adaptiveThreshold(warped, dst, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 19, 9);

          resultCanvas.width = maxWidth;
          resultCanvas.height = maxHeight;
          cv.imshow(resultCanvas, dst);

          warped.delete(); srcTri.delete(); dstTri.delete(); M.delete();
          pageContour.delete();
        } else {
          // æ²’æ‰¾åˆ°æ–‡ä»¶ï¼Œç›´æ¥å¼·åŒ–å°æ¯”
          cv.adaptiveThreshold(gray, dst, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 19, 9);
          resultCanvas.width = gray.cols;
          resultCanvas.height = gray.rows;
          cv.imshow(resultCanvas, dst);
        }

        resolve(resultCanvas.toDataURL('image/jpeg', 0.92));
        src.delete(); dst.delete(); gray.delete(); blurred.delete(); edged.delete(); contours.delete(); hierarchy.delete();
      });
    }

    async function handleFiles(files) {
      if (!cvReady) {
        alert("OpenCV è¼‰å…¥ä¸­ï¼Œè«‹ç¨å€™å†è©¦ï¼");
        return;
      }
      document.getElementById('loading').style.display = '';
      for (let file of files) {
        if (!file.type.startsWith('image/')) continue;
        await new Promise((resolve) => {
          const reader = new FileReader();
          reader.onload = async e => {
            const img = new Image();
            img.onload = async () => {
              const processedDataUrl = await processImageAutoCropAndEnhance(img);
              images.push(processedDataUrl);
              updatePreview();
              resolve();
            };
            img.src = e.target.result;
          };
          reader.readAsDataURL(file);
        });
      }
      document.getElementById('loading').style.display = 'none';
    }

    document.getElementById('cameraInput').addEventListener('change', e => {
      handleFiles(e.target.files);
      e.target.value = '';
    });
    document.getElementById('fileInput').addEventListener('change', e => {
      handleFiles(e.target.files);
      e.target.value = '';
    });

    function updatePreview() {
      const preview = document.getElementById('preview');
      preview.innerHTML = '';
      images.forEach((src, i) => {
        const div = document.createElement('div');
        div.className = 'preview-item';
        const img = document.createElement('img');
        img.src = src;
        const btn = document.createElement('button');
        btn.className = 'remove-btn';
        btn.textContent = 'âœ–';
        btn.onclick = () => {
          images.splice(i, 1);
          updatePreview();
        };
        div.appendChild(img);
        div.appendChild(btn);
        preview.appendChild(div);
      });
    }

    // å‘½åè¦å‰‡ï¼šYYYYMMDD_HHmmss_è½‰æª”.pdf
    function getPdfFilename() {
      const now = new Date();
      const yyyy = now.getFullYear();
      const mm = String(now.getMonth() + 1).padStart(2, "0");
      const dd = String(now.getDate()).padStart(2, "0");
      const hh = String(now.getHours()).padStart(2, "0");
      const min = String(now.getMinutes()).padStart(2, "0");
      const ss = String(now.getSeconds()).padStart(2, "0");
      return `${yyyy}${mm}${dd}_${hh}${min}${ss}_è½‰æª”.pdf`;
    }

    function generatePDF() {
      if (images.length === 0) {
        alert('è«‹å…ˆæ–°å¢ç…§ç‰‡');
        return;
      }
      const pdf = new jsPDF({ unit: 'pt', format: 'a4' });
      let first = true;
      images.forEach((src, idx) => {
        const img = new Image();
        img.onload = () => {
          let pdfW = pdf.internal.pageSize.getWidth();
          let pdfH = pdf.internal.pageSize.getHeight();
          let ratio = Math.min(pdfW / img.width, pdfH / img.height);
          let w = img.width * ratio, h = img.height * ratio;
          let x = (pdfW - w) / 2, y = (pdfH - h) / 2;
          if (!first) pdf.addPage();
          pdf.addImage(img, 'JPEG', x, y, w, h);
          if (idx === images.length - 1) {
            pdf.save(getPdfFilename());
          }
        };
        img.src = src;
        first = false;
      });
    }
  </script>
</body>
</html>
