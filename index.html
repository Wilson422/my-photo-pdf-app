<input type="file" accept="image/*" capture="environment" id="fileInput" />

<canvas id="canvasOriginal" style="display:none;"></canvas>
<canvas id="canvasProcessed"></canvas>

<button id="btnNext" disabled>下一步：生成PDF</button>

<script async src="https://docs.opencv.org/4.x/opencv.js" type="text/javascript"></script>
<script>
  const fileInput = document.getElementById('fileInput');
  const canvasOriginal = document.getElementById('canvasOriginal');
  const canvasProcessed = document.getElementById('canvasProcessed');
  const btnNext = document.getElementById('btnNext');

  let processedImageDataUrl = null;  // 裁切後圖片base64

  fileInput.addEventListener('change', () => {
    let file = fileInput.files[0];
    if (!file) return;
    let img = new Image();
    img.onload = () => {
      // 顯示原始圖片在隱藏canvas (供opencv讀取)
      canvasOriginal.width = img.width;
      canvasOriginal.height = img.height;
      let ctx = canvasOriginal.getContext('2d');
      ctx.drawImage(img, 0, 0);

      if (cv && cv.ready) {
        processImage();
      } else {
        cv['onRuntimeInitialized'] = processImage;
      }
    }
    img.src = URL.createObjectURL(file);
  });

  function processImage() {
    let src = cv.imread(canvasOriginal);
    let dst = new cv.Mat();
    let gray = new cv.Mat();
    let edges = new cv.Mat();

    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
    cv.GaussianBlur(gray, gray, new cv.Size(5, 5), 0);
    cv.Canny(gray, edges, 75, 200);

    let contours = new cv.MatVector();
    let hierarchy = new cv.Mat();
    cv.findContours(edges, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);

    let maxContour = null;
    let maxArea = 0;
    for (let i = 0; i < contours.size(); i++) {
      let cnt = contours.get(i);
      let area = cv.contourArea(cnt);
      if (area > maxArea) {
        maxArea = area;
        maxContour = cnt;
      }
    }

    if (maxContour) {
      let peri = cv.arcLength(maxContour, true);
      let approx = new cv.Mat();
      cv.approxPolyDP(maxContour, approx, 0.02 * peri, true);

      if (approx.rows === 4) {
        let pts = [];
        for (let i = 0; i < 4; i++) {
          pts.push({
            x: approx.intPtr(i, 0)[0],
            y: approx.intPtr(i, 0)[1],
          });
        }
        pts = sortPoints(pts);

        let widthA = distance(pts[2], pts[3]);
        let widthB = distance(pts[1], pts[0]);
        let maxWidth = Math.max(widthA, widthB);

        let heightA = distance(pts[1], pts[2]);
        let heightB = distance(pts[0], pts[3]);
        let maxHeight = Math.max(heightA, heightB);

        let dstCoords = cv.matFromArray(4, 1, cv.CV_32FC2, [
          0, 0,
          maxWidth - 1, 0,
          maxWidth - 1, maxHeight - 1,
          0, maxHeight - 1,
        ]);
        let srcCoords = cv.matFromArray(4, 1, cv.CV_32FC2, [
          pts[0].x, pts[0].y,
          pts[1].x, pts[1].y,
          pts[2].x, pts[2].y,
          pts[3].x, pts[3].y,
        ]);

        let M = cv.getPerspectiveTransform(srcCoords, dstCoords);
        cv.warpPerspective(src, dst, M, new cv.Size(maxWidth, maxHeight), cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());

        cv.imshow(canvasProcessed, dst);

        // 把裁切後的圖轉成 base64，後續可以用來生成PDF或分享
        processedImageDataUrl = canvasProcessed.toDataURL('image/jpeg');

        M.delete(); dstCoords.delete(); srcCoords.delete();
      } else {
        alert("找不到四邊形輪廓，無法做裁切，會用原圖代替");
        cv.imshow(canvasProcessed, src);
        processedImageDataUrl = canvasProcessed.toDataURL('image/jpeg');
      }
      approx.delete();
    } else {
      alert("找不到輪廓，請試試拍清楚或用其他圖片");
      cv.imshow(canvasProcessed, src);
      processedImageDataUrl = canvasProcessed.toDataURL('image/jpeg');
    }

    src.delete(); dst.delete(); gray.delete(); edges.delete(); contours.delete(); hierarchy.delete();

    btnNext.disabled = false; // 啟用下一步按鈕
  }

  function distance(p1, p2) {
    return Math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2);
  }
  function sortPoints(pts) {
    pts.sort((a, b) => a.x - b.x);
    let left = pts.slice(0, 2);
    let right = pts.slice(2, 4);
    left.sort((a, b) => a.y - b.y);
    right.sort((a, b) => a.y - b.y);
    return [left[0], right[0], right[1], left[1]];
  }

  btnNext.addEventListener('click', () => {
    if (!processedImageDataUrl) {
      alert('還沒準備好圖片喔！');
      return;
    }
    // 這裡你可以呼叫你的PDF生成功能，傳入 processedImageDataUrl
    console.log('下一步，生成PDF或其他行為', processedImageDataUrl);
    alert('這邊可接PDF生成，或保存分享功能');
  });
</script>
