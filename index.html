<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <title>OpenCV.js 文件邊緣偵測＋裁切</title>
  <style>
    canvas {
      max-width: 90vw;
      max-height: 60vh;
      border: 1px solid #333;
    }
  </style>
</head>
<body>

  <h2>選擇圖片</h2>
  <input type="file" id="fileInput" accept="image/*" />
  <br/><br/>

  <canvas id="canvasInput"></canvas>
  <canvas id="canvasOutput"></canvas>

  <script async src="https://docs.opencv.org/4.x/opencv.js" type="text/javascript"></script>
  <script>
    let inputCanvas = document.getElementById('canvasInput');
    let outputCanvas = document.getElementById('canvasOutput');
    let fileInput = document.getElementById('fileInput');

    fileInput.addEventListener('change', (e) => {
      let file = e.target.files[0];
      if (!file) return;
      let img = new Image();
      img.onload = () => {
        // 顯示原圖
        inputCanvas.width = img.width;
        inputCanvas.height = img.height;
        let ctx = inputCanvas.getContext('2d');
        ctx.drawImage(img, 0, 0);

        // 等 OpenCV.js 載入後才做處理
        if (cv && cv.ready) {
          processImage();
        } else {
          cv['onRuntimeInitialized']=processImage;
        }
      };
      img.src = URL.createObjectURL(file);
    });

    function processImage() {
      let src = cv.imread(inputCanvas);
      let dst = new cv.Mat();
      let gray = new cv.Mat();
      let edges = new cv.Mat();

      // 灰階
      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
      // 用高斯模糊降低雜訊
      cv.GaussianBlur(gray, gray, new cv.Size(5, 5), 0);
      // Canny 邊緣偵測
      cv.Canny(gray, edges, 75, 200);

      // 找輪廓
      let contours = new cv.MatVector();
      let hierarchy = new cv.Mat();
      cv.findContours(edges, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);

      // 找最大輪廓
      let maxContour = null;
      let maxArea = 0;
      for (let i = 0; i < contours.size(); i++) {
        let cnt = contours.get(i);
        let area = cv.contourArea(cnt);
        if (area > maxArea) {
          maxArea = area;
          maxContour = cnt;
        }
      }

      if (maxContour) {
        // 多邊形近似輪廓
        let peri = cv.arcLength(maxContour, true);
        let approx = new cv.Mat();
        cv.approxPolyDP(maxContour, approx, 0.02 * peri, true);

        // 如果是四邊形，當作文件邊界來做透視變換
        if (approx.rows === 4) {
          // 取得四點坐標
          let pts = [];
          for (let i = 0; i < 4; i++) {
            pts.push({
              x: approx.intPtr(i, 0)[0],
              y: approx.intPtr(i, 0)[1],
            });
          }
          // 排序四點（左上、右上、右下、左下）
          pts = sortPoints(pts);

          // 計算透視變換尺寸
          let widthA = distance(pts[2], pts[3]);
          let widthB = distance(pts[1], pts[0]);
          let maxWidth = Math.max(widthA, widthB);

          let heightA = distance(pts[1], pts[2]);
          let heightB = distance(pts[0], pts[3]);
          let maxHeight = Math.max(heightA, heightB);

          // 目標點座標
          let dstCoords = cv.matFromArray(4, 1, cv.CV_32FC2, [
            0, 0,
            maxWidth - 1, 0,
            maxWidth - 1, maxHeight - 1,
            0, maxHeight - 1,
          ]);
          // 原始點座標
          let srcCoords = cv.matFromArray(4, 1, cv.CV_32FC2, [
            pts[0].x, pts[0].y,
            pts[1].x, pts[1].y,
            pts[2].x, pts[2].y,
            pts[3].x, pts[3].y,
          ]);

          let M = cv.getPerspectiveTransform(srcCoords, dstCoords);
          cv.warpPerspective(src, dst, M, new cv.Size(maxWidth, maxHeight), cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());

          cv.imshow(outputCanvas, dst);

          // 清理記憶體
          M.delete(); dstCoords.delete(); srcCoords.delete();
        } else {
          alert("找不到四邊形輪廓，無法做透視裁切。");
        }

        approx.delete();
      } else {
        alert("找不到輪廓，請試試調整圖片或重新拍攝。");
      }

      // 清理記憶體
      src.delete(); dst.delete(); gray.delete(); edges.delete(); contours.delete(); hierarchy.delete();
    }

    // 工具函數：計算兩點距離
    function distance(p1, p2) {
      return Math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2);
    }

    // 工具函數：排序四點為左上、右上、右下、左下
    function sortPoints(pts) {
      // 先依 x 排序，左邊兩點是左上左下，右邊兩點是右上右下
      pts.sort((a, b) => a.x - b.x);
      let left = pts.slice(0, 2);
      let right = pts.slice(2, 4);
      left.sort((a, b) => a.y - b.y);
      right.sort((a, b) => a.y - b.y);
      return [left[0], right[0], right[1], left[1]];
    }
  </script>
</body>
</html>
