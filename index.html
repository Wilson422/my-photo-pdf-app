<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>æ–‡ä»¶æ‹ç…§è½‰ PDFï¼ˆç²¾ç°¡ç‰ˆï¼‰</title>
<style>
  body { font-family: Arial,"Noto Sans TC",sans-serif; margin:1.1em; background:#fff; }
  h2 { margin-top:0; font-size:1.15em; }
  .actions { display:flex; flex-wrap:wrap; gap:.5em; align-items:center; margin-bottom:.7em; }
  .actions input[type=file]{ display:none; }
  button { background:#f5f5f5; border:none; padding:.55em .95em; font-size:.9em; border-radius:8px; cursor:pointer; }
  button:hover { background:#e7e7e7; }
  button.danger { background:#ffecec; color:#b80000; }
  #loading { display:none; font-size:.75em; font-weight:bold; color:#003; }

  #storageInfo { font-size:.8em; color:#555; margin:.3em 0 .6em; }
  #preview { display:flex; flex-wrap:wrap; gap:10px; }

  .thumb { position:relative; width:140px; background:#fafafa; padding:8px 8px 32px; border-radius:8px;
           box-sizing:border-box; cursor:pointer; }
  .thumb img { width:100%; height:auto; display:block; border:1px solid #ddd; border-radius:6px; background:#fff; }
  .order-label { position:absolute; top:6px; left:6px; background:#1976d2; color:#fff; font-size:11px;
                 padding:3px 6px; border-radius:6px; font-weight:bold; }
  .remove-btn { position:absolute; top:6px; right:6px; background:#ff4d4d; color:#fff; border:none;
                font-size:11px; padding:4px 6px; border-radius:6px; cursor:pointer; }

  /* Cropper Modal */
  #cropperModal { position:fixed; inset:0; background:rgba(0,0,0,.72); display:none;
                  align-items:center; justify-content:center; z-index:10000; }
  #cropperModal .modal-content {
    background:#fff; width:94vw; max-width:1000px; max-height:88vh; overflow:auto;
    padding:14px 14px 16px; border-radius:12px; box-sizing:border-box; display:flex;
    flex-direction:column; align-items:center;
  }
  #cropperTip { font-size:.78em; color:#333; margin-bottom:.55em; text-align:center; }
  .canvas-wrapper { position:relative; background:#111; border-radius:8px; }
  #cropperCanvas { display:block; background:#222; border-radius:6px; touch-action:none; }

  .handle {
    position:absolute; width:28px; height:28px; margin-left:-14px; margin-top:-14px;
    background:#1976d2; border:3px solid #fff; border-radius:50%; box-shadow:0 2px 6px rgba(0,0,0,.55);
    cursor:grab; touch-action:none;
  }
  .handle:active { cursor:grabbing; }

  .controls { margin-top:8px; display:flex; gap:.6em; flex-wrap:wrap; font-size:.78em; align-items:center; }
  select { padding:.35em .55em; border-radius:6px; border:1px solid #ccc; background:#fff; font-size:.85em; }
  #autoDetectStatus { font-size:.68em; color:#555; min-height:1em; }
  #cropperBtns { margin-top:10px; display:flex; gap:.6em; }
  #cropperBtns button { font-size:.8em; }

  #lineOverlay {
    position:fixed; inset:0; background:rgba(0,0,0,.82); display:none; align-items:center; justify-content:center;
    z-index:15000; padding:18px;
  }
  #lineOverlay .box {
    background:#222; color:#fff; padding:20px 24px; border-radius:14px; max-width:460px; font-size:.9em;
    line-height:1.5;
  }
  #lineOverlay button { background:#1976d2; color:#fff; margin-top:12px; }
  #lineOverlay button.secondary { background:#555; margin-left:8px; }
  #lineOverlay code { background:#333; padding:2px 5px; border-radius:4px; word-break:break-all; display:block; margin-top:4px; }

  @media (max-width:560px){
    .thumb { width:32vw; max-width:155px; }
    .handle { width:34px; height:34px; margin-left:-17px; margin-top:-17px; }
    #cropperModal .modal-content { padding:12px; }
  }
</style>
</head>
<body>
<h2>ğŸ“„ æ–‡ä»¶æ‹ç…§è½‰ PDF</h2>

<div class="actions">
  <input id="cameraInput" type="file" accept="image/*" capture="environment">
  <input id="fileInput" type="file" accept="image/*" multiple>
  <button onclick="triggerCamera()">ğŸ“· æ‹ç…§</button>
  <button onclick="triggerFile()">ğŸ–¼ï¸ é¸ç…§ç‰‡</button>
  <button onclick="generatePDF()">ğŸ§¾ ç”¢ç”Ÿ PDF</button>
  <button class="danger" onclick="clearAllImages()">ğŸ—‘ï¸ æ¸…é™¤å…¨éƒ¨</button>
  <span id="loading">è™•ç†ä¸­...</span>
</div>

<div id="storageInfo">ç›®å‰åœ–ç‰‡æ•¸é‡ï¼š0</div>
<div id="preview"></div>

<!-- LINE Browser Warning -->
<div id="lineOverlay">
  <div class="box">
    <h3 style="margin-top:0;font-size:1.05em;">è«‹ä½¿ç”¨ç³»çµ±é è¨­ç€è¦½å™¨é–‹å•Ÿ</h3>
    <p>åµæ¸¬åˆ°ä½ æ­£åœ¨ä½¿ç”¨ LINE å…§å»ºç€è¦½å™¨ï¼Œå¯èƒ½å°è‡´ç›¸æ©Ÿæˆ–æª”æ¡ˆåŠŸèƒ½å—é™ã€‚è«‹æ”¹ç”¨ Safari / Chrome é–‹å•Ÿï¼Œæˆ–è¤‡è£½ä¸‹æ–¹ç¶²å€ã€‚</p>
    <code id="lineUrl"></code>
    <div>
      <button id="copyLineUrlBtn">è¤‡è£½ç¶²å€</button>
      <button class="secondary" id="lineContinueBtn">æˆ‘å·²äº†è§£ï¼Œç¹¼çºŒ</button>
    </div>
  </div>
</div>

<!-- Cropper Modal -->
<div id="cropperModal" role="dialog" aria-modal="true">
  <div class="modal-content">
    <div id="cropperTip">æ‹–æ›³å››å€‹è—é»å°æº–æ–‡ä»¶å››è§’ã€‚é›™æ“Šç•«é¢å¯é‡è¨­ã€‚è‹¥è‡ªå‹•åµæ¸¬ä¸æº–å¯å†æŒ‰ä¸€æ¬¡â€œè‡ªå‹•â€ã€‚</div>
    <div id="canvasContainer" class="canvas-wrapper">
      <canvas id="cropperCanvas" width="800" height="600"></canvas>
    </div>
    <div class="controls">
      <label>æ•ˆæœï¼š
        <select id="effectSelect">
          <option value="original">åŸè‰²</option>
          <option value="gray">ç°éš</option>
          <option value="bw">é»‘ç™½</option>
        </select>
      </label>
      <button id="autoDetectBtn" style="font-size:.75em;">ğŸ” è‡ªå‹•</button>
      <span id="autoDetectStatus"></span>
    </div>
    <div id="cropperBtns">
      <button id="cropResetBtn">é‡è¨­</button>
      <button id="cropConfirmBtn">ç¢ºå®šè£åˆ‡</button>
      <button id="cropCancelBtn">å–æ¶ˆ</button>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
<script>
/* ============ Config & State ============ */
const CONFIG = {
  FULL_MAX_DIM: 2000,
  PREVIEW_MAX_WIDTH: 420,
  IMAGE_QUALITY: 0.9
};
const { jsPDF } = window.jspdf || {};
let images = []; // {id, originalDataUrl, fullDataUrl, previewDataUrl, w,h, cropRelPoints:[{u,v}*4], effect}
let editingImageId = null; // è‹¥ç‚ºå†æ¬¡ç·¨è¼¯

/* ============ LINE Browser Detect ============ */
function isLineBrowser(){
  const ua = navigator.userAgent || '';
  return /Line\/|LINE\//.test(ua);
}
function showLineOverlay(){
  if (!isLineBrowser()) return;
  const ov = document.getElementById('lineOverlay');
  document.getElementById('lineUrl').textContent = location.href;
  ov.style.display = 'flex';
  document.getElementById('copyLineUrlBtn').onclick = () => {
    navigator.clipboard.writeText(location.href).then(()=>alert('å·²è¤‡è£½ç¶²å€'));
  };
  document.getElementById('lineContinueBtn').onclick = ()=> { ov.style.display='none'; };
}

/* ============ EXIF Orientation + Heuristic ============ */
async function loadImageNormalized(file){
  const arrayBuffer = await file.arrayBuffer();
  let orientation = getExifOrientation(arrayBuffer);
  let dataUrl;

  if (self.createImageBitmap) {
    try {
      const bmp = await createImageBitmap(new Blob([arrayBuffer]), { imageOrientation: 'from-image' });
      dataUrl = bitmapToDataURL(bmp);
    } catch(e){}
  }
  if (!dataUrl) {
    dataUrl = await blobToDataURL(new Blob([arrayBuffer], { type: file.type || 'image/jpeg'}));
  }

  if (orientation !== 1) {
    dataUrl = await fixByOrientation(dataUrl, orientation);
  } else {
    // ç„¡ EXIF æ™‚ä¹‹å•Ÿç™¼å¼æ—‹è½‰ï¼šå¯¬é«˜æ¯” > 1.3 ä¸” <=2.2 è¦–ç‚ºç›´æ‹æ©«èºº â†’ æ—‹è½‰ 90Â°
    const img = await loadImg(dataUrl);
    const ratio = img.naturalWidth / img.naturalHeight;
    if (ratio > 1.3 && ratio <= 2.2) {
      dataUrl = rotate90(img);
    }
  }
  return dataUrl;
}

function getExifOrientation(buffer){
  try {
    const view = new DataView(buffer);
    if (view.getUint16(0,false) !== 0xFFD8) return 1;
    let offset=2;
    while (offset < view.byteLength) {
      const marker = view.getUint16(offset,false); offset += 2;
      if (marker === 0xFFE1) {
        const size = view.getUint16(offset,false);
        const exifHeader = offset + 2;
        if (view.getUint32(exifHeader,false) !== 0x45786966) return 1;
        const tiff = exifHeader + 6;
        const little = (view.getUint16(tiff,false) === 0x4949);
        if (view.getUint16(tiff+2,little) !== 0x002A) return 1;
        let ifdOffset = view.getUint32(tiff+4,little) + tiff;
        const entries = view.getUint16(ifdOffset,little);
        for (let i=0;i<entries;i++){
          const entry = ifdOffset+2+i*12;
          if (view.getUint16(entry,little) === 0x0112) {
            return view.getUint16(entry+8,little) || 1;
          }
        }
        return 1;
      } else if (marker === 0xFFDA) break;
      else {
        const size=view.getUint16(offset,false);
        offset += size;
      }
    }
  } catch(e){}
  return 1;
}
function fixByOrientation(dataUrl, orientation){
  return new Promise(res=>{
    if (orientation===1) return res(dataUrl);
    const img = new Image();
    img.onload = ()=>{
      const w=img.naturalWidth, h=img.naturalHeight;
      const c=document.createElement('canvas');
      const ctx=c.getContext('2d');
      switch(orientation){
        case 2: c.width=w;c.height=h;ctx.translate(w,0);ctx.scale(-1,1);break;
        case 3: c.width=w;c.height=h;ctx.translate(w,h);ctx.rotate(Math.PI);break;
        case 4: c.width=w;c.height=h;ctx.translate(0,h);ctx.scale(1,-1);break;
        case 5: c.width=h;c.height=w;ctx.rotate(Math.PI/2);ctx.scale(1,-1);break;
        case 6: c.width=h;c.height=w;ctx.rotate(Math.PI/2);ctx.translate(0,-h);break;
        case 7: c.width=h;c.height=w;ctx.rotate(Math.PI/2);ctx.translate(w,-h);ctx.scale(-1,1);break;
        case 8: c.width=h;c.height=w;ctx.rotate(-Math.PI/2);ctx.translate(-h,0);break;
        default: c.width=w;c.height=h;
      }
      ctx.drawImage(img,0,0);
      res(c.toDataURL('image/jpeg', CONFIG.IMAGE_QUALITY));
    };
    img.onerror=()=>res(dataUrl);
    img.src=dataUrl;
  });
}
function rotate90(img){
  const c=document.createElement('canvas'), ctx=c.getContext('2d');
  c.width=img.naturalHeight; c.height=img.naturalWidth;
  ctx.translate(c.width,0); ctx.rotate(Math.PI/2);
  ctx.drawImage(img,0,0);
  return c.toDataURL('image/jpeg', CONFIG.IMAGE_QUALITY);
}
function bitmapToDataURL(bmp){
  const c=document.createElement('canvas'); c.width=bmp.width; c.height=bmp.height;
  c.getContext('2d').drawImage(bmp,0,0);
  return c.toDataURL('image/jpeg', CONFIG.IMAGE_QUALITY);
}
function blobToDataURL(blob){
  return new Promise((res,rej)=>{
    const fr=new FileReader();
    fr.onload=e=>res(e.target.result);
    fr.onerror=rej;
    fr.readAsDataURL(blob);
  });
}
function loadImg(url){
  return new Promise((res,rej)=>{
    const i=new Image();
    i.onload=()=>res(i);
    i.onerror=rej;
    i.src=url;
  });
}

/* ============ Improved Auto Corner Detection ============ */
function autoDetectCorners(img){
  try {
    const MAX_SIDE=900;
    const scale=Math.min(1, MAX_SIDE/Math.max(img.width,img.height));
    const sw=Math.round(img.width*scale), sh=Math.round(img.height*scale);
    const c=document.createElement('canvas'); c.width=sw; c.height=sh;
    const ctx=c.getContext('2d');
    ctx.drawImage(img,0,0,sw,sh);
    const data=ctx.getImageData(0,0,sw,sh); const d=data.data;

    // ç°éš
    const gray=new Uint8ClampedArray(sw*sh);
    for (let i=0,j=0;i<d.length;i+=4,j++){
      gray[j]=(0.299*d[i]+0.587*d[i+1]+0.114*d[i+2])|0;
    }

    // 2 æ¬¡ç›’ç‹€æ¨¡ç³Š (åŠå¾‘=1)
    function boxBlur(src,w,h){
      const out=new Uint8ClampedArray(src.length);
      for (let y=0;y<h;y++){
        for (let x=0;x<w;x++){
          let sum=0,count=0;
          for (let ky=-1;ky<=1;ky++){
            const yy=y+ky; if (yy<0||yy>=h) continue;
            for (let kx=-1;kx<=1;kx++){
              const xx=x+kx; if (xx<0||xx>=w) continue;
              sum+=src[yy*w+xx]; count++;
            }
          }
          out[y*w+x]=(sum/count)|0;
        }
      }
      return out;
    }
    let blurred=boxBlur(gray,sw,sh);
    blurred=boxBlur(blurred,sw,sh);

    // Sobel
    const gxK=[-1,0,1,-2,0,2,-1,0,1];
    const gyK=[-1,-2,-1,0,0,0,1,2,1];
    const mag=new Float32Array(sw*sh);

    for (let y=1;y<sh-1;y++){
      for (let x=1;x<sw-1;x++){
        let gx=0,gy=0,idx=0;
        for (let ky=-1;ky<=1;ky++){
          for (let kx=-1;kx<=1;kx++){
            const v=blurred[(y+ky)*sw+(x+kx)];
            gx+=v*gxK[idx]; gy+=v*gyK[idx]; idx++;
          }
        }
        mag[y*sw+x]=Math.hypot(gx,gy);
      }
    }
    // å–æ¢¯åº¦å¼·åº¦åˆ†ä½æ•¸ (80th percentile)
    const mags = Array.from(mag).filter(v=>v>0);
    if (!mags.length) return null;
    mags.sort((a,b)=>a-b);
    const thresh = mags[Math.floor(mags.length*0.80)];
    const edge=new Uint8Array(sw*sh);
    for (let i=0;i<mag.length;i++) edge[i]=mag[i]>=thresh?1:0;

    // é€£é€šå…ƒä»¶ (DFS/BFS)
    const visited=new Uint8Array(sw*sh);
    let bestQuad=null;
    let bestArea=0;

    const stack=[];
    const pts=[];
    function push(x,y){ stack.push({x,y}); visited[y*sw+x]=1; }

    for (let y=0;y<sh;y++){
      for (let x=0;x<sw;x++){
        const idx=y*sw+x;
        if (!edge[idx] || visited[idx]) continue;
        stack.length=0; pts.length=0;
        push(x,y);
        while(stack.length){
          const p=stack.pop();
          pts.push(p);
          for (let dy=-1;dy<=1;dy++){
            for (let dx=-1;dx<=1;dx++){
              if (!dx && !dy) continue;
              const nx=p.x+dx, ny=p.y+dy;
              if (nx<0||ny<0||nx>=sw||ny>=sh) continue;
              const ni=ny*sw+nx;
              if (edge[ni] && !visited[ni]) push(nx,ny);
            }
          }
        }
        if (pts.length < (sw*sh*0.002)) continue; // å¤ªå°å¿½ç•¥

        // å‡¸åŒ…
        const hull = convexHull(pts);
        if (hull.length < 4) continue;

        const quad = extractQuadFromHull(hull);
        if (!quad) continue;

        // é¢ç©
        const area = polygonArea(quad);
        if (area > bestArea){
          bestArea = area;
          bestQuad = quad;
        }
      }
    }
    if (!bestQuad) return null;

    // å°‡åº§æ¨™æ”¾å¤§å›åŸå°ºå¯¸
    const inv = 1/scale;
    const mapped = bestQuad.map(p=>({ x: p.x*inv, y:p.y*inv }));
    // æ’åºç‚º TL TR BR BL
    return orderQuad(mapped);
  } catch(e){
    console.warn('autoDetect error', e);
    return null;
  }
}

function convexHull(points){
  points = points.slice().sort((a,b)=> a.x===b.x ? a.y-b.y : a.x-b.x);
  function cross(o,a,b){ return (a.x-o.x)*(b.y-o.y) - (a.y-o.y)*(b.x-o.x); }
  const lower=[];
  for (const p of points){
    while (lower.length>=2 && cross(lower[lower.length-2], lower[lower.length-1], p) <= 0) lower.pop();
    lower.push(p);
  }
  const upper=[];
  for (let i=points.length-1;i>=0;i--){
    const p=points[i];
    while (upper.length>=2 && cross(upper[upper.length-2], upper[upper.length-1], p) <= 0) upper.pop();
    upper.push(p);
  }
  upper.pop(); lower.pop();
  return lower.concat(upper);
}

function extractQuadFromHull(hull){
  if (hull.length===4) return hull;
  // heuristic: å–æœ€å¤§è·é›¢å° (A,B)ï¼Œå†å–é›¢ AB æœ€é é» Cï¼Œå†å–ä½¿é¢ç©æœ€å¤§çš„ D
  let maxDist=-1, A=null,B=null;
  for (let i=0;i<hull.length;i++){
    for (let j=i+1;j<hull.length;j++){
      const d=dist(hull[i], hull[j]);
      if (d>maxDist){ maxDist=d; A=hull[i]; B=hull[j]; }
    }
  }
  if (!A||!B) return null;
  let maxDistLine=-1, C=null;
  for (const p of hull){
    if (p===A||p===B) continue;
    const d=lineDist(A,B,p);
    if (d>maxDistLine){ maxDistLine=d; C=p; }
  }
  if (!C) return null;
  let maxArea=-1, D=null;
  for (const p of hull){
    if (p===A||p===B||p===C) continue;
    const area = polygonArea([A,B,C,p]);
    if (area>maxArea){ maxArea=area; D=p; }
  }
  if (!D) return null;
  return [A,B,C,D];
}

function polygonArea(pts){
  let a=0;
  for (let i=0;i<pts.length;i++){
    const p1=pts[i], p2=pts[(i+1)%pts.length];
    a += p1.x*p2.y - p2.x*p1.y;
  }
  return Math.abs(a)/2;
}
function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }
function lineDist(a,b,p){
  const num = Math.abs((b.y-a.y)*p.x - (b.x-a.x)*p.y + b.x*a.y - b.y*a.x);
  const den = Math.hypot(b.x-a.x, b.y-a.y) || 1;
  return num / den;
}

function orderQuad(pts){
  // TL: min x+y, BR: max x+y, TR: max x - y, BL: min x - y
  let tl, tr, br, bl;
  let minSum=Infinity, maxSum=-Infinity, minDiff=Infinity, maxDiff=-Infinity;
  for (const p of pts){
    const s=p.x+p.y, d=p.x-p.y;
    if (s<minSum){ minSum=s; tl=p; }
    if (s>maxSum){ maxSum=s; br=p; }
    if (d>maxDiff){ maxDiff=d; tr=p; }
    if (d<minDiff){ minDiff=d; bl=p; }
  }
  return [tl,tr,br,bl];
}

/* ============ Cropper ============ */
function openCropper(originalDataUrl, existingRelPoints){
  return new Promise((resolve,reject)=>{
    const modal=document.getElementById('cropperModal');
    const canvas=document.getElementById('cropperCanvas');
    const wrapper=document.getElementById('canvasContainer');
    const effectSel=document.getElementById('effectSelect');
    const statusEl=document.getElementById('autoDetectStatus');
    let ctx=canvas.getContext('2d');

    modal.style.display='flex';

    const img=new Image();
    let handles=[]; // [{u,v}*4]
    let handleEls=[];
    let imgDraw={dx:0,dy:0,dw:0,dh:0,scale:1};
    let dragging=-1;
    let lastTap=0;
    let autoTried=false;

    function ensureHandles(){
      for (let i=0;i<4;i++){
        if (!handleEls[i]){
          const el=document.createElement('div');
          el.className='handle';
          el.dataset.idx=i;
          el.addEventListener('pointerdown', ev=>ev.preventDefault());
          wrapper.appendChild(el);
          handleEls[i]=el;
        }
      }
    }
    function positionHandles(){
      for (let i=0;i<4;i++){
        const h=handles[i];
        const x=imgDraw.dx + h.u*imgDraw.dw;
        const y=imgDraw.dy + h.v*imgDraw.dh;
        handleEls[i].style.left=x+'px';
        handleEls[i].style.top=y+'px';
      }
    }
    function draw(){
      ctx.save();
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.restore();

      ctx.drawImage(img,0,0,img.width,img.height,imgDraw.dx,imgDraw.dy,imgDraw.dw,imgDraw.dh);

      // highlight polygon
      ctx.save();
      ctx.fillStyle='rgba(0,0,0,.45)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.globalCompositeOperation='destination-out';
      ctx.beginPath();
      for (let i=0;i<4;i++){
        const p=handles[i];
        const x=imgDraw.dx + p.u*imgDraw.dw;
        const y=imgDraw.dy + p.v*imgDraw.dh;
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.closePath(); ctx.fill();
      ctx.restore();

      ctx.lineWidth=2.4;
      ctx.strokeStyle='#26a0ff';
      ctx.beginPath();
      for (let i=0;i<4;i++){
        const p=handles[i];
        const x=imgDraw.dx + p.u*imgDraw.dw;
        const y=imgDraw.dy + p.v*imgDraw.dh;
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.closePath();
      ctx.stroke();
    }
    function defaultHandles(){
      const inset=0.06;
      handles = [
        {u:inset,v:inset},
        {u:1-inset,v:inset},
        {u:1-inset,v:1-inset},
        {u:inset,v:1-inset}
      ];
    }
    function setHandlesFromQuad(quad){
      handles = quad.map(p=>({ u: p.x / img.width, v: p.y / img.height }));
    }
    function applyExistingRelPoints(rel){
      if (!rel || rel.length!==4) return false;
      handles = rel.map(p=>({u:p.u,v:p.v}));
      return true;
    }
    function attemptAutoDetect(){
      statusEl.textContent='åµæ¸¬ä¸­...';
      setTimeout(()=>{
        try {
          const quad = autoDetectCorners(img);
          if (quad){
            setHandlesFromQuad(quad);
            statusEl.textContent='è‡ªå‹•åµæ¸¬ âœ”';
          } else {
            if (!autoTried) statusEl.textContent='åµæ¸¬å¤±æ•— (ä½¿ç”¨é è¨­)';
            else statusEl.textContent='æœªæ‰¾åˆ°æ–‡ä»¶';
          }
        } catch(e){
          statusEl.textContent='åµæ¸¬éŒ¯èª¤';
        }
        positionHandles();
        draw();
        autoTried=true;
      }, 10);
    }

    function pointerDown(e){
      const rect=canvas.getBoundingClientRect();
      const x=e.clientX-rect.left;
      const y=e.clientY-rect.top;
      let best=-1,bestD=Infinity;
      for (let i=0;i<4;i++){
        const px=imgDraw.dx + handles[i].u*imgDraw.dw;
        const py=imgDraw.dy + handles[i].v*imgDraw.dh;
        const d=Math.hypot(px-x,py-y);
        if (d<bestD){ bestD=d; best=i; }
      }
      if (bestD<=40){
        dragging=best;
        try { wrapper.setPointerCapture(e.pointerId); } catch(_){}
        window.addEventListener('pointermove', pointerMove, {passive:false});
        window.addEventListener('pointerup', pointerUp, {passive:false});
        e.preventDefault();
      } else {
        const now=Date.now();
        if (now-lastTap<300){
          defaultHandles();
          positionHandles();
          draw();
          statusEl.textContent='å·²é‡è¨­';
        }
        lastTap=now;
      }
    }
    function pointerMove(e){
      if (dragging<0) return;
      const rect=canvas.getBoundingClientRect();
      const x=e.clientX-rect.left;
      const y=e.clientY-rect.top;
      const u=(x - imgDraw.dx)/imgDraw.dw;
      const v=(y - imgDraw.dy)/imgDraw.dh;
      handles[dragging].u=Math.max(0,Math.min(1,u));
      handles[dragging].v=Math.max(0,Math.min(1,v));
      positionHandles(); draw();
      e.preventDefault();
    }
    function pointerUp(e){
      dragging=-1;
      window.removeEventListener('pointermove', pointerMove);
      window.removeEventListener('pointerup', pointerUp);
      try { wrapper.releasePointerCapture(e.pointerId); } catch(_){}
    }

    document.getElementById('autoDetectBtn').onclick=()=>attemptAutoDetect();
    document.getElementById('cropResetBtn').onclick=()=>{
      defaultHandles(); positionHandles(); draw(); statusEl.textContent='å·²é‡è¨­';
    };
    document.getElementById('cropCancelBtn').onclick=()=>{
      cleanup(); reject('cancel');
    };

    document.getElementById('cropConfirmBtn').onclick=()=>{
      // å°‡ handles â†’ å¯¦éš›åƒç´ 
      const srcPts = handles.map(h=>({ x: Math.round(h.u*img.width), y: Math.round(h.v*img.height) }));
      // æ¨ç®—è¼¸å‡ºå°ºå¯¸ï¼šå–å°é‚Šæœ€å¤§
      function dist(a,b){ return Math.hypot(a.x-b.x,a.y-b.y); }
      const wA=dist(srcPts[2],srcPts[3]), wB=dist(srcPts[1],srcPts[0]);
      const hA=dist(srcPts[1],srcPts[2]), hB=dist(srcPts[0],srcPts[3]);
      const dstW=Math.min(Math.round(Math.max(wA,wB)), CONFIG.FULL_MAX_DIM);
      const dstH=Math.min(Math.round(Math.max(hA,hB)), CONFIG.FULL_MAX_DIM);

      const dstPts=[{x:0,y:0},{x:dstW-1,y:0},{x:dstW-1,y:dstH-1},{x:0,y:dstH-1}];
      const H = computeHomography(srcPts,dstPts);
      if (!H){ alert('è¨ˆç®—å¤±æ•—ï¼Œè«‹èª¿æ•´å†è©¦'); return; }

      const srcCanvas = document.createElement('canvas');
      srcCanvas.width=img.width; srcCanvas.height=img.height;
      srcCanvas.getContext('2d').drawImage(img,0,0);

      const warped = warpWithH(srcCanvas,H,dstW,dstH);
      applyEffect(warped, effectSel.value);
      const relPoints = handles.map(h=>({u:h.u,v:h.v}));
      cleanup();
      resolve({ croppedCanvas: warped, relPoints, effect: effectSel.value });
    };

    function cleanup(){
      modal.style.display='none';
      handleEls.forEach(el=>{ if (el && el.parentNode) el.parentNode.removeChild(el); });
      handleEls=[];
      wrapper.removeEventListener('pointerdown', pointerDown);
    }

    img.onload=()=>{
      // layout canvas
      const winW=Math.min(window.innerWidth*0.92,1100);
      const winH=Math.min(window.innerHeight*0.70,1000);
      const fit = Math.min(winW/img.width, winH/img.height, 1);
      const dispW=Math.max(320, Math.round(img.width*fit));
      const dispH=Math.max(240, Math.round(img.height*fit));
      const dpr=window.devicePixelRatio||1;
      canvas.style.width=dispW+'px';
      canvas.style.height=dispH+'px';
      canvas.width=Math.round(dispW*dpr);
      canvas.height=Math.round(dispH*dpr);
      ctx=canvas.getContext('2d');
      ctx.setTransform(dpr,0,0,dpr,0,0);

      const scale=Math.min(dispW/img.width, dispH/img.height);
      const dw=Math.round(img.width*scale);
      const dh=Math.round(img.height*scale);
      const dx=Math.round((dispW-dw)/2);
      const dy=Math.round((dispH-dh)/2);
      imgDraw={dx,dy,dw,dh,scale};

      ensureHandles();
      if (!applyExistingRelPoints(existingRelPoints)) defaultHandles();
      positionHandles();
      draw();

      // åˆæ¬¡è‡ªå‹•åµæ¸¬ï¼ˆè‹¥ä½¿ç”¨è€…å·²æœ‰æ—¢å­˜é»å‰‡ä»å¯å†æŒ‰â€œè‡ªå‹•â€è¦†è“‹ï¼‰
      if (!existingRelPoints) attemptAutoDetect();

      wrapper.addEventListener('pointerdown', pointerDown, {passive:false});
    };
    img.onerror=()=>{ modal.style.display='none'; reject('img_load_error'); };
    img.src=originalDataUrl;
  });
}

/* ============ Homography & Warp & Effects (simplified) ============ */
function computeHomography(srcPts,dstPts){
  const A=[], b=[];
  for (let i=0;i<4;i++){
    const {x,y}=srcPts[i], {x:u,y:v}=dstPts[i];
    A.push([x,y,1,0,0,0,-u*x,-u*y]); b.push(u);
    A.push([0,0,0,x,y,1,-v*x,-v*y]); b.push(v);
  }
  const h=solveLinear(A,b);
  if(!h) return null;
  return [[h[0],h[1],h[2]],[h[3],h[4],h[5]],[h[6],h[7],1]];
}
function solveLinear(A,b){
  const n=A.length;
  const M=A.map((r,i)=>r.concat(b[i]));
  for (let k=0;k<n;k++){
    let im=k;
    for (let i=k+1;i<n;i++) if (Math.abs(M[i][k])>Math.abs(M[im][k])) im=i;
    if (Math.abs(M[im][k])<1e-12) return null;
    [M[k],M[im]]=[M[im],M[k]];
    const piv=M[k][k];
    for (let j=k;j<=n;j++) M[k][j]/=piv;
    for (let i=0;i<n;i++){
      if (i===k) continue;
      const f=M[i][k];
      for (let j=k;j<=n;j++) M[i][j]-=f*M[k][j];
    }
  }
  return M.map(r=>r[n]);
}
function invert3x3(m){
  const a=m[0][0],b=m[0][1],c=m[0][2],
        d=m[1][0],e=m[1][1],f=m[1][2],
        g=m[2][0],h=m[2][1],i=m[2][2];
  const A=e*i-f*h,B=c*h-b*i,C=b*f-c*e;
  const D=f*g-d*i,E=a*i-c*g,F=c*d-a*f;
  const G=d*h-e*g,H=b*g-a*h,I=a*e-b*d;
  const det=a*A+b*D+c*G;
  if (Math.abs(det)<1e-12) return null;
  const inv=1/det;
  return [[A*inv,B*inv,C*inv],[D*inv,E*inv,F*inv],[G*inv,H*inv,I*inv]];
}
function warpWithH(srcCanvas,H,dstW,dstH){
  const dst=document.createElement('canvas');
  dst.width=dstW; dst.height=dstH;
  const dctx=dst.getContext('2d');
  const sctx=srcCanvas.getContext('2d');
  const srcW=srcCanvas.width, srcH=srcCanvas.height;
  const srcData=sctx.getImageData(0,0,srcW,srcH).data;
  const out=dctx.createImageData(dstW,dstH);
  const outData=out.data;
  const Hinv=invert3x3(H);
  if (!Hinv){ dctx.drawImage(srcCanvas,0,0,dstW,dstH); return dst; }
  for (let y=0;y<dstH;y++){
    for (let x=0;x<dstW;x++){
      const denom = Hinv[2][0]*x + Hinv[2][1]*y + Hinv[2][2];
      if (!denom) continue;
      const sx=(Hinv[0][0]*x + Hinv[0][1]*y + Hinv[0][2])/denom;
      const sy=(Hinv[1][0]*x + Hinv[1][1]*y + Hinv[1][2])/denom;
      let r=255,g=255,b=255,a=255;
      if (sx>=0&&sy>=0&&sx<srcW&&sy<srcH){
        const x0=Math.floor(sx), y0=Math.floor(sy);
        const x1=Math.min(x0+1,srcW-1), y1=Math.min(y0+1,srcH-1);
        const dx=sx-x0, dy=sy-y0;
        const i00=(y0*srcW+x0)*4, i10=(y0*srcW+x1)*4;
        const i01=(y1*srcW+x0)*4, i11=(y1*srcW+x1)*4;
        function lerp(a,b,t){ return a+(b-a)*t; }
        const p00=[srcData[i00],srcData[i00+1],srcData[i00+2],srcData[i00+3]];
        const p10=[srcData[i10],srcData[i10+1],srcData[i10+2],srcData[i10+3]];
        const p01=[srcData[i01],srcData[i01+1],srcData[i01+2],srcData[i01+3]];
        const p11=[srcData[i11],srcData[i11+1],srcData[i11+2],srcData[i11+3]];
        const p0=p00.map((v,c)=>lerp(v,p10[c],dx));
        const p1=p01.map((v,c)=>lerp(v,p11[c],dx));
        const p=p0.map((v,c)=>lerp(v,p1[c],dy));
        [r,g,b,a]=p;
      }
      const oi=(y*dstW+x)*4;
      outData[oi]=r; outData[oi+1]=g; outData[oi+2]=b; outData[oi+3]=a;
    }
  }
  dctx.putImageData(out,0,0);
  return dst;
}
function applyEffect(canvas, effect){
  if (effect==='original') return;
  const ctx=canvas.getContext('2d');
  const imgd=ctx.getImageData(0,0,canvas.width,canvas.height);
  const d=imgd.data;
  // ç°éš
  for (let i=0;i<d.length;i+=4){
    const r=d[i], g=d[i+1], b=d[i+2];
    const lum=0.299*r + 0.587*g + 0.114*b;
    d[i]=d[i+1]=d[i+2]=lum;
  }
  if (effect==='bw'){
    // Otsu
    const hist=new Array(256).fill(0);
    for (let i=0;i<d.length;i+=4) hist[d[i]]++;
    let sum=0; for (let t=0;t<256;t++) sum+=t*hist[t];
    const total=canvas.width*canvas.height;
    let wB=0,sumB=0,varMax=0,th=0;
    for (let t=0;t<256;t++){
      wB+=hist[t]; if(!wB) continue;
      const wF=total-wB; if(!wF) break;
      sumB+=t*hist[t];
      const mB=sumB/wB;
      const mF=(sum-sumB)/wF;
      const between=wB*wF*(mB-mF)*(mB-mF);
      if (between>varMax){ varMax=between; th=t; }
    }
    for (let i=0;i<d.length;i+=4){
      const v=d[i]>th?255:0;
      d[i]=d[i+1]=d[i+2]=v;
    }
  }
  ctx.putImageData(imgd,0,0);
}

/* ============ Resize pipeline ============ */
function createResizedCanvas(img, maxDim){
  const r=img.width/img.height;
  let w=img.width,h=img.height;
  if (w>h){ if (w>maxDim){ w=maxDim; h=Math.round(w/r);} }
  else { if (h>maxDim){ h=maxDim; w=Math.round(h*r);} }
  const c=document.createElement('canvas'); c.width=w; c.height=h;
  const ctx=c.getContext('2d'); ctx.fillStyle='#fff'; ctx.fillRect(0,0,w,h);
  ctx.drawImage(img,0,0,img.width,img.height,0,0,w,h);
  return c;
}
function processCroppedCanvas(croppedCanvas){
  return new Promise(res=>{
    const tmp=new Image();
    tmp.onload=()=>{
      const full=createResizedCanvas(tmp, CONFIG.FULL_MAX_DIM);
      const fullUrl=full.toDataURL('image/jpeg', CONFIG.IMAGE_QUALITY);
      const preview=createResizedCanvas(tmp, CONFIG.PREVIEW_MAX_WIDTH);
      const previewUrl=preview.toDataURL('image/jpeg', 0.75);
      res({fullUrl, previewUrl, w:full.width, h:full.height});
    };
    tmp.src=croppedCanvas.toDataURL('image/jpeg',0.95);
  });
}

/* ============ File Handling ============ */
function handleFiles(fileList){
  if(!fileList || !fileList.length) return;
  document.getElementById('loading').style.display='';
  let i=0;
  (function next(){
    if (i>=fileList.length){
      document.getElementById('loading').style.display='none';
      return;
    }
    const f=fileList[i++];
    if(!f.type.startsWith('image/')) return next();
    (async ()=>{
      try {
        const normalized = await loadImageNormalized(f);
        editingImageId = null; // æ–°å¢
        const { croppedCanvas, relPoints, effect } = await openCropper(normalized, null);
        const processed = await processCroppedCanvas(croppedCanvas);
        images.push({
          id: Date.now().toString(36)+Math.random().toString(36).slice(2,8),
          originalDataUrl: normalized,
          fullDataUrl: processed.fullUrl,
          previewDataUrl: processed.previewUrl,
          w: processed.w,
          h: processed.h,
          cropRelPoints: relPoints,
          effect
        });
        updatePreview();
      } catch(e){
        if (e!=='cancel') console.warn(e);
      } finally {
        next();
      }
    })();
  })();
}

document.getElementById('cameraInput').addEventListener('change', e=>{
  handleFiles(e.target.files);
  e.target.value='';
});
document.getElementById('fileInput').addEventListener('change', e=>{
  handleFiles(e.target.files);
  e.target.value='';
});

/* ============ Re-edit Crop ============ */
function reEditImage(id){
  const imgObj = images.find(x=>x.id===id);
  if (!imgObj) return;
  editingImageId = id;
  openCropper(imgObj.originalDataUrl, imgObj.cropRelPoints)
    .then(async ({croppedCanvas, relPoints, effect})=>{
      const processed = await processCroppedCanvas(croppedCanvas);
      imgObj.fullDataUrl = processed.fullUrl;
      imgObj.previewDataUrl = processed.previewUrl;
      imgObj.w = processed.w;
      imgObj.h = processed.h;
      imgObj.cropRelPoints = relPoints;
      imgObj.effect = effect;
      updatePreview();
    })
    .catch(err => {
      if (err!=='cancel') console.warn(err);
    });
}

/* ============ Preview UI ============ */
function updatePreview(){
  const c=document.getElementById('preview');
  c.innerHTML='';
  images.forEach((o,idx)=>{
    const div=document.createElement('div');
    div.className='thumb';
    div.title='é»æ“Šé‡æ–°è£åˆ‡';
    div.onclick=()=>reEditImage(o.id);

    const order=document.createElement('div');
    order.className='order-label';
    order.textContent=idx+1;
    div.appendChild(order);

    const img=document.createElement('img');
    img.src=o.previewDataUrl;
    div.appendChild(img);

    const del=document.createElement('button');
    del.className='remove-btn';
    del.textContent='X';
    del.onclick=(e)=>{
      e.stopPropagation();
      images = images.filter(x=>x.id!==o.id);
      updatePreview();
    };
    div.appendChild(del);

    c.appendChild(div);
  });
  updateStorageInfo();
}
function updateStorageInfo(){
  document.getElementById('storageInfo').textContent = `ç›®å‰åœ–ç‰‡æ•¸é‡ï¼š${images.length}`;
}

/* ============ Simple Actions ============ */
function clearAllImages(){
  if (!images.length) return;
  if (confirm('ç¢ºå®šåˆªé™¤å…¨éƒ¨åœ–ç‰‡ï¼Ÿ')){
    images=[];
    updatePreview();
  }
}
function triggerCamera(){ document.getElementById('cameraInput').click(); }
function triggerFile(){ document.getElementById('fileInput').click(); }

function getPdfFilename(){
  const d=new Date(), p=n=>String(n).padStart(2,'0');
  return `${d.getFullYear()}${p(d.getMonth()+1)}${p(d.getDate())}_${p(d.getHours())}${p(d.getMinutes())}${p(d.getSeconds())}_è½‰æª”.pdf`;
}

function generatePDF(){
  if (!images.length){ alert('è«‹å…ˆåŠ å…¥åœ–ç‰‡'); return; }
  const firstLandscape = images[0].w > images[0].h;
  const pdf = new jsPDF({unit:'pt', format:'a4', orientation:firstLandscape?'landscape':'portrait'});
  images.forEach((o,idx)=>{
    if (idx>0){
      pdf.addPage('a4', (o.w>o.h)?'landscape':'portrait');
    }
    const pw=pdf.internal.pageSize.getWidth(), ph=pdf.internal.pageSize.getHeight();
    const ratio=Math.min(pw/o.w, ph/o.h);
    const w=o.w*ratio, h=o.h*ratio;
    pdf.addImage(o.fullDataUrl,'JPEG',(pw-w)/2,(ph-h)/2,w,h);
  });
  pdf.save(getPdfFilename());
}

/* ============ Init ============ */
window.addEventListener('DOMContentLoaded', ()=>{
  showLineOverlay();
  updatePreview();
});

/* ============ Exported for clarity (none) ============ */
</script>
</body>
</html>
