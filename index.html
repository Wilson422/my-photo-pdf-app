<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>æ–‡ä»¶æ‹ç…§è½‰ PDFï¼ˆè£åˆ‡ / A4 å¼•å° / é›™æŒ‡ç¸®æ”¾ï¼‰</title>
<style>
  body {
    font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif;
    margin:12px;
    background:#f7f7f7;
    line-height:1.5;
  }
  h2 { margin:0 0 .4em; font-size:1.35em; }
  .actions {
    display:flex; flex-wrap:wrap; gap:.7em; align-items:center; margin-bottom:.9em;
  }
  .actions input[type=file]{ display:none; }
  .actions button {
    background:#fff; border:1px solid #ccc; padding:.55em .9em; border-radius:8px; cursor:pointer;
    font-size:.95em; line-height:1.1;
  }
  .actions button:hover { background:#f0f0f0; }
  .actions button:active { background:#e2e2e2; }
  button.danger { background:#ffecec; border-color:#f3b5b5; color:#b40000; }
  button.danger:hover { background:#ffdede; }
  #loading { display:none; font-size:.85em; font-weight:bold; color:#003; }
  #storageInfo { font-size:.85em; color:#666; margin-top:-4px; }
  #preview { display:flex; flex-wrap:wrap; gap:10px; margin-top:.7em; }
  .thumb {
    position:relative; width:140px; background:#fff; border:1px solid #ddd;
    border-radius:10px; padding:6px 6px 30px; box-sizing:border-box; cursor:pointer;
  }
  .thumb img { width:100%; height:100px; object-fit:cover; border-radius:6px; }
  .order-label {
    position:absolute; top:6px; left:6px; background:#0078d7; color:#fff;
    font-size:12px; padding:3px 6px; border-radius:6px; font-weight:600;
  }
  .remove-btn {
    position:absolute; top:6px; right:6px; background:#ff4545; color:#fff;
    border:none; font-size:12px; padding:3px 6px; border-radius:6px; cursor:pointer;
  }
  .remove-btn:hover { background:#e53636; }

  /* Modal */
  #cropperModal {
    position:fixed; inset:0; background:rgba(0,0,0,0.78);
    display:none; z-index:9999;
    /* Use flex full screen */
    display:flex; flex-direction:column;
  }
  #cropperModal.active { display:flex; }
  #cropHeader {
    background:#fff; padding:6px 10px; font-size:.85em; text-align:center;
    box-shadow:0 2px 4px rgba(0,0,0,.08);
  }
  #cropMain {
    flex:1; display:flex; flex-direction:column; min-height:0;
    background:#222;
  }
  #canvasStageWrapper {
    flex:1; position:relative; min-height:0; overflow:hidden;
    display:flex; align-items:center; justify-content:center;
    background:#111;
  }
  canvas#cropCanvas {
    touch-action:none;
    background:#333;
    border:1px solid #444;
    max-width:100%;
    max-height:100%;
  }
  .handle {
    position:absolute;
    width:30px; height:30px;
    margin:-15px 0 0 -15px;
    background:#0d79ff;
    border:3px solid #fff;
    border-radius:50%;
    box-shadow:0 3px 8px rgba(0,0,0,.45);
    cursor:grab;
    touch-action:none;
  }
  .handle:active { cursor:grabbing; }
  #cropFooter {
    background:#fff; padding:8px 10px;
    box-shadow:0 -2px 4px rgba(0,0,0,.08);
  }
  #cropControls {
    display:flex; flex-wrap:wrap; gap:.6em; align-items:center; justify-content:center;
    margin-bottom:.5em;
  }
  #cropControls select, #cropControls button {
    font-size:.9em; padding:.55em .8em; border-radius:7px;
    border:1px solid #ccc; background:#fafafa; cursor:pointer;
  }
  #cropControls button:hover { background:#eee; }
  #cropButtons {
    display:flex; gap:.7em; justify-content:center; flex-wrap:wrap;
  }
  #cropButtons button {
    font-size:.95em; padding:.65em 1.1em; border-radius:8px; border:1px solid #ccc; background:#fff; cursor:pointer;
  }
  #cropConfirmBtn {
    background:#0078d7; border-color:#0078d7; color:#fff; font-weight:600;
  }
  #cropConfirmBtn:hover { background:#0269ba; }
  #cropCancelBtn { background:#f0f0f0; }
  #autoDetectStatus { font-size:.72em; color:#555; min-width:5em; text-align:center; }

  /* Yellow A4 Guide line (drawn on canvas, not DOM) */

  /* Mobile adjustments */
  @media (max-width:600px){
    h2 { font-size:1.18em; }
    .actions button { font-size:.85em; padding:.55em .7em; }
    .thumb { width:44vw; max-width:170px; }
    .thumb img { height:90px; }
    .handle { width:34px; height:34px; margin:-17px 0 0 -17px; }
  }

  /* LINE bar */
  #lineWarningBar {
    display:none;
    background:#fff8c8;
    border:1px solid #f2de7b;
    padding:.55em .8em;
    border-radius:6px;
    font-size:.75em;
    margin-bottom:.6em;
    color:#523;
  }
  #lineWarningBar button {
    font-size:.65em; margin-left:.6em; padding:.3em .5em;
    background:#fff1a0; border:1px solid #d4c060; border-radius:4px; cursor:pointer;
  }
</style>
</head>
<body>
<div id="lineWarningBar">
  åµæ¸¬åˆ°æ‚¨ä½¿ç”¨ LINE å…§å»ºç€è¦½å™¨ï¼Œå¯èƒ½å½±éŸ¿æ‹ç…§èˆ‡ä¸‹è¼‰ç©©å®šã€‚å»ºè­°æ”¹ç”¨ç³»çµ±ç€è¦½å™¨ã€‚
  <button onclick="this.parentNode.remove()">é—œé–‰</button>
</div>

<h2>ğŸ“„ æ–‡ä»¶æ‹ç…§è½‰ PDF</h2>
<div class="actions">
  <input id="cameraInput" type="file" accept="image/*" capture="environment">
  <input id="fileInput" type="file" accept="image/*" multiple>
  <button onclick="triggerCamera()">ğŸ“· æ‹ç…§</button>
  <button onclick="triggerFile()">ğŸ–¼ï¸ é¸ç…§ç‰‡</button>
  <button onclick="generatePDF()">ğŸ§¾ ç”¢ç”Ÿ PDF</button>
  <button class="danger" onclick="clearAllImages()">ğŸ—‘ æ¸…é™¤å…¨éƒ¨</button>
  <span id="loading">è™•ç†ä¸­...</span>
</div>
<div id="storageInfo">ç›®å‰åœ–ç‰‡æ•¸é‡ï¼š0</div>
<div id="preview"></div>

<!-- Cropper Modal -->
<div id="cropperModal">
  <div id="cropHeader">
    <strong>è£åˆ‡èª¿æ•´</strong>ï¼šæ‹–æ›³è—é»ï¼Œé›™æŒ‡ç¸®æ”¾/ç§»å‹•ã€‚é›™æ“Šç©ºç™½é‡è¨­ã€‚
    <span id="autoDetectStatus"></span>
  </div>
  <div id="cropMain">
    <div id="canvasStageWrapper">
      <canvas id="cropCanvas" width="800" height="600"></canvas>
      <!-- handles æœƒå‹•æ…‹æ’å…¥ -->
    </div>
  </div>
  <div id="cropFooter">
    <div id="cropControls">
      <label>æ•ˆæœ
        <select id="effectSelect">
          <option value="original">åŸè‰²</option>
          <option value="color_scan">å½©è‰²æƒææ„Ÿ</option>
          <option value="gray">ç°éš</option>
          <option value="bw">é»‘ç™½äºŒå€¼</option>
        </select>
      </label>
      <button id="autoDetectBtn">ğŸ” è‡ªå‹•å››è§’</button>
      <button id="rotateBtn">â†º æ—‹è½‰90Â°</button>
      <button id="resetViewBtn">ğŸ§­ é‡è¨­è¦–åœ–</button>
    </div>
    <div id="cropButtons">
      <button id="cropCancelBtn">å–æ¶ˆ</button>
      <button id="cropResetBtn">é‡è¨­å››è§’</button>
      <button id="cropConfirmBtn">ç¢ºå®šè£åˆ‡</button>
    </div>
  </div>
</div>

<script>
/* ----------------------------------
   å°å·¥å…· / EXIF æ–¹å‘
---------------------------------- */
const CONFIG = { FULL_MAX_DIM: 2000, PREVIEW_MAX_WIDTH: 420, IMAGE_QUALITY: 0.9 };
const { jsPDF } = window.jspdf || {};
let images = [];

function detectLineInApp(){
  const ua = navigator.userAgent || '';
  // åš´æ ¼ï¼šéœ€çœŸçš„å« Line/æ•¸å­—ï¼Œä¸”éå…¸å‹æ¡Œé¢ Chrome
  const isLine = /\bLine\/\d/i.test(ua) && /(Android|iPhone|iPad|iOS)/i.test(ua);
  if (isLine){
    document.getElementById('lineWarningBar').style.display='block';
  }
}
detectLineInApp();

async function loadImageNormalized(file){
  const buffer = await file.arrayBuffer();
  if (self.createImageBitmap){
    try {
      const bmp = await createImageBitmap(new Blob([buffer]), { imageOrientation:'from-image' });
      const c = document.createElement('canvas');
      c.width=bmp.width; c.height=bmp.height;
      c.getContext('2d').drawImage(bmp,0,0);
      return c.toDataURL('image/jpeg', CONFIG.IMAGE_QUALITY);
    } catch(e){}
  }
  const ori = getExifOrientation(buffer);
  const dataUrl = await blobToDataURL(new Blob([buffer],{type:file.type||'image/jpeg'}));
  if (ori===1) return dataUrl;
  return await fixOrientation(dataUrl, ori);
}
function blobToDataURL(blob){ return new Promise((res,rej)=>{ const fr=new FileReader(); fr.onload=e=>res(e.target.result); fr.onerror=rej; fr.readAsDataURL(blob); }); }
function getExifOrientation(buf){
  try {
    const dv = new DataView(buf);
    if (dv.getUint16(0,false)!==0xFFD8) return 1;
    let off=2;
    while (off < dv.byteLength){
      const marker = dv.getUint16(off,false); off+=2;
      if (marker===0xFFE1){
        if (dv.getUint32(off+2,false)!==0x45786966) return 1;
        const tiff = off+8;
        const little = dv.getUint16(tiff,false)===0x4949;
        let ifd = dv.getUint32(tiff+4,little)+tiff;
        const entries = dv.getUint16(ifd,little);
        for (let i=0;i<entries;i++){
          const eOff = ifd+2+i*12;
          if (dv.getUint16(eOff,little)===0x0112){
            return dv.getUint16(eOff+8,little)||1;
          }
        }
        return 1;
      } else if (marker===0xFFDA) break;
      else off += dv.getUint16(off,false);
    }
  } catch(_){}
  return 1;
}
function fixOrientation(dataUrl, ori){
  return new Promise(r=>{
    const img=new Image();
    img.onload=()=>{
      const w=img.naturalWidth, h=img.naturalHeight;
      const c=document.createElement('canvas'), ctx=c.getContext('2d');
      if ([5,6,7,8].includes(ori)){ c.width=h; c.height=w; } else { c.width=w; c.height=h; }
      switch(ori){
        case 2: ctx.transform(-1,0,0,1,w,0); break;
        case 3: ctx.transform(-1,0,0,-1,w,h); break;
        case 4: ctx.transform(1,0,0,-1,0,h); break;
        case 5: ctx.transform(0,1,1,0,0,0); break;
        case 6: ctx.transform(0,1,-1,0,h,0); break;
        case 7: ctx.transform(0,-1,-1,0,h,w); break;
        case 8: ctx.transform(0,-1,1,0,0,w); break;
      }
      ctx.drawImage(img,0,0);
      r(c.toDataURL('image/jpeg', CONFIG.IMAGE_QUALITY));
    };
    img.onerror=()=>r(dataUrl);
    img.src=dataUrl;
  });
}

/* ----------------------------------
   è‡ªå‹•å››è§’åµæ¸¬ (å’Œä¹‹å‰é‚è¼¯é¡ä¼¼ï¼Œä¿ç•™)
---------------------------------- */
function autoDetectDocumentCorners(img){
  const MAX=800;
  const scale=Math.min(1, MAX/Math.max(img.width,img.height));
  const sw=img.width*scale|0, sh=img.height*scale|0;
  const c=document.createElement('canvas'); c.width=sw; c.height=sh;
  const ctx=c.getContext('2d'); ctx.drawImage(img,0,0,sw,sh);
  const { data }=ctx.getImageData(0,0,sw,sh);
  const gray=new Uint8ClampedArray(sw*sh);
  for (let i=0,j=0;i<data.length;i+=4,j++) gray[j]=(0.299*data[i]+0.587*data[i+1]+0.114*data[i+2])|0;
  // ç°¡åŒ–ï¼šé‚Šç·£ + hull
  const edge=new Uint8Array(sw*sh);
  for (let y=1;y<sh-1;y++){
    for (let x=1;x<sw-1;x++){
      const i=y*sw+x;
      const gx= gray[i+1]-gray[i-1];
      const gy= gray[i+sw]-gray[i-sw];
      if (Math.hypot(gx,gy)>28) edge[i]=1;
    }
  }
  const pts=[];
  for (let y=0;y<sh;y++) for (let x=0;x<sw;x++) if (edge[y*sw+x]) pts.push({x,y});
  if (pts.length<50) return null;
  // convex hull (monotonic)
  pts.sort((a,b)=>a.x===b.x?a.y-b.y:a.x-b.x);
  function cross(o,a,b){ return (a.x-o.x)*(b.y-o.y)-(a.y-o.y)*(b.x-o.x); }
  const lower=[], upper=[];
  for (const p of pts){ while(lower.length>=2 && cross(lower[lower.length-2], lower[lower.length-1], p)<=0) lower.pop(); lower.push(p); }
  for (let i=pts.length-1;i>=0;i--){ const p=pts[i]; while(upper.length>=2 && cross(upper[upper.length-2], upper[upper.length-1], p)<=0) upper.pop(); upper.push(p); }
  upper.pop(); lower.pop();
  const hull=lower.concat(upper);
  if (hull.length<4) return null;
  // é¸å››å€‹è§’
  let tl,tr,br,bl;
  let minSum=Infinity,maxSum=-Infinity,minDiff=Infinity,maxDiff=-Infinity;
  for (const p of hull){
    const s=p.x+p.y, d=p.x-p.y;
    if (s<minSum){ minSum=s; tl=p; }
    if (s>maxSum){ maxSum=s; br=p; }
    if (d>maxDiff){ maxDiff=d; tr=p; }
    if (d<minDiff){ minDiff=d; bl=p; }
  }
  const inv=1/scale;
  return [tl,tr,br,bl].map(p=>({ x:p.x*inv, y:p.y*inv }));
}

/* ----------------------------------
   é€è¦– / åŒå‰ç‰ˆæœ¬
---------------------------------- */
function solveLinearSystem(A,b){
  // ç°¡å–® Gaussian
  const n=A.length; const M=A.map((r,i)=>r.slice().concat(b[i]));
  for(let i=0;i<n;i++){
    // pivot
    let max=i;
    for(let r=i+1;r<n;r++) if (Math.abs(M[r][i])>Math.abs(M[max][i])) max=r;
    if (Math.abs(M[max][i])<1e-12) return null;
    [M[i],M[max]]=[M[max],M[i]];
    const div=M[i][i];
    for(let c=i;c<=n;c++) M[i][c]/=div;
    for(let r=0;r<n;r++) if (r!==i){
      const f=M[r][i];
      for(let c=i;c<=n;c++) M[r][c]-=f*M[i][c];
    }
  }
  return M.map(r=>r[n]);
}
function computeHomography(src,dst){
  const A=[], B=[];
  for (let i=0;i<4;i++){
    const {x,y}=src[i], {x:U,y:V}=dst[i];
    A.push([x,y,1,0,0,0,-U*x,-U*y]); B.push(U);
    A.push([0,0,0,x,y,1,-V*x,-V*y]); B.push(V);
  }
  const h=solveLinearSystem(A,B);
  if(!h) return null;
  return [[h[0],h[1],h[2]],[h[3],h[4],h[5]],[h[6],h[7],1]];
}
function invert3x3(m){
  const a=m[0][0],b=m[0][1],c=m[0][2], d=m[1][0],e=m[1][1],f=m[1][2], g=m[2][0],h=m[2][1],i=m[2][2];
  const A=e*i-f*h,B=c*h-b*i,C=b*f-c*e,D=f*g-d*i,E=a*i-c*g,F=c*d-a*f,G=d*h-e*g,H=b*g-a*h,I=a*e-b*d;
  const det=a*A+b*D+c*G; if (Math.abs(det)<1e-12) return null;
  const inv=1/det;
  return [[A*inv,B*inv,C*inv],[D*inv,E*inv,F*inv],[G*inv,H*inv,I*inv]];
}
function warpImage(srcImg,H,dstW,dstH){
  const can=document.createElement('canvas'); can.width=dstW; can.height=dstH;
  const sC=document.createElement('canvas'); sC.width=srcImg.width; sC.height=srcImg.height;
  sC.getContext('2d').drawImage(srcImg,0,0);
  const sdat=sC.getContext('2d').getImageData(0,0,sC.width,sC.height);
  const dctx=can.getContext('2d');
  const out=dctx.createImageData(dstW,dstH);
  const inv=invert3x3(H); if(!inv){ dctx.drawImage(srcImg,0,0,dstW,dstH); return can; }
  const [a,b,c,d,e,f,g,h,i]=[inv[0][0],inv[0][1],inv[0][2],inv[1][0],inv[1][1],inv[1][2],inv[2][0],inv[2][1],inv[2][2]];
  const sw=sC.width, sh=sC.height, sdata=sdat.data, ddata=out.data;
  for (let y=0;y<dstH;y++){
    for (let x=0;x<dstW;x++){
      const denom = g*x + h*y + i;
      const sx=(a*x + b*y + c)/denom;
      const sy=(d*x + e*y + f)/denom;
      const di=(y*dstW+x)*4;
      if (sx>=0 && sy>=0 && sx<sw-1 && sy<sh-1){
        const x0=sx|0, y0=sy|0;
        const dx=sx-x0, dy=sy-y0, dx1=1-dx, dy1=1-dy;
        const i00=(y0*sw+x0)*4;
        const i10=i00+4;
        const i01=i00+sw*4;
        const i11=i01+4;
        for (let k=0;k<4;k++){
          ddata[di+k] = sdata[i00+k]*dx1*dy1 + sdata[i10+k]*dx*dy1 + sdata[i01+k]*dx1*dy + sdata[i11+k]*dx*dy;
        }
      } else {
        ddata[di]=ddata[di+1]=ddata[di+2]=255; ddata[di+3]=255;
      }
    }
  }
  dctx.putImageData(out,0,0);
  return can;
}

/* ----------------------------------
   æ•ˆæœ
---------------------------------- */
function applyEffect(canvas, effect){
  if (!effect || effect==='original') return;
  const ctx=canvas.getContext('2d');
  const imgd=ctx.getImageData(0,0,canvas.width,canvas.height);
  const d=imgd.data;
  if (effect==='color_scan'){
    const contrast=1.25, bright=0.08*255;
    for (let i=0;i<d.length;i+=4){
      d[i]   = Math.max(0,Math.min(255, contrast*(d[i]-128)+128+bright));
      d[i+1] = Math.max(0,Math.min(255, contrast*(d[i+1]-128)+128+bright));
      d[i+2] = Math.max(0,Math.min(255, contrast*(d[i+2]-128)+128+bright));
    }
  } else if (effect==='gray' || effect==='bw'){
    for (let i=0;i<d.length;i+=4){
      const v=0.299*d[i]+0.587*d[i+1]+0.114*d[i+2];
      d[i]=d[i+1]=d[i+2]=v;
    }
    if (effect==='bw'){
      const hist=new Array(256).fill(0);
      for (let i=0;i<d.length;i+=4) hist[d[i]]++;
      const total=canvas.width*canvas.height;
      let sum=0; for(let t=0;t<256;t++) sum+=t*hist[t];
      let wB=0, sumB=0, varMax=0, threshold=128;
      for (let t=0;t<256;t++){
        wB+=hist[t]; if(!wB) continue;
        const wF=total-wB; if(!wF) break;
        sumB+=t*hist[t];
        const mB=sumB/wB, mF=(sum-sumB)/wF;
        const between=wB*wF*(mB-mF)*(mB-mF);
        if (between>varMax){ varMax=between; threshold=t; }
      }
      for (let i=0;i<d.length;i+=4){
        const val= d[i] > threshold ? 255 : 0;
        d[i]=d[i+1]=d[i+2]=val;
      }
    }
  }
  ctx.putImageData(imgd,0,0);
}

/* ----------------------------------
   è£åˆ‡ UIï¼šç©©å®š + é›™æŒ‡ç¸®æ”¾
---------------------------------- */
async function openCropper(dataUrl, opts={}){
  return new Promise((resolve,reject)=>{
    const modal = document.getElementById('cropperModal');
    const canvas = document.getElementById('cropCanvas');
    const effectSelect = document.getElementById('effectSelect');
    const statusEl = document.getElementById('autoDetectStatus');
    const autoBtn = document.getElementById('autoDetectBtn');
    const rotateBtn = document.getElementById('rotateBtn');
    const resetViewBtn = document.getElementById('resetViewBtn');
    const cancelBtn = document.getElementById('cropCancelBtn');
    const confirmBtn = document.getElementById('cropConfirmBtn');
    const resetQuadBtn = document.getElementById('cropResetBtn');
    const stageWrapper = document.getElementById('canvasStageWrapper');
    const ctx = canvas.getContext('2d');

    // State
    let img = new Image();
    let rotation = opts.initialRotation||0;
    let baseScale = 1; // åœ–ç‰‡é©é…ç•«å¸ƒçš„åŸºç¤å€æ•¸
    let zoom = 1;
    let panX = 0; // åœ¨ canvas åº§æ¨™ç³» (å·¦ä¸Šç‚º 0,0) ä¸‹çš„åç§»
    let panY = 0;

    // å››è§’ (image ç©ºé–“çš„ 0~img.width / 0~img.height)
    let corners = opts.initialQuad
      ? opts.initialQuad.map(p=>({ x:p.x, y:p.y }))
      : null;

    // äº’å‹•
    let draggingHandle = -1;
    let activePointers = new Map();
    let lastDistance = null;
    let lastMid = null;

    // å»ºç«‹ handle DOM
    const handlesDom = [];
    function ensureHandles(){
      for (let i=0;i<4;i++){
        if (!handlesDom[i]){
          const h=document.createElement('div');
            h.className='handle';
            h.dataset.idx=i;
            stageWrapper.appendChild(h);
            handlesDom[i]=h;
        }
      }
    }

    function setInitialCorners(){
      const inset = 0.06;
      corners = [
        { x: img.width*inset, y: img.height*inset },
        { x: img.width*(1-inset), y: img.height*inset },
        { x: img.width*(1-inset), y: img.height*(1-inset) },
        { x: img.width*inset, y: img.height*(1-inset) }
      ];
    }

    function resizeCanvas(){
      // è®“ canvas è²¼æ»¿ wrapper
      const rect = stageWrapper.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;
      computeBasePlacement();
      draw();
    }

    function computeBasePlacement(){
      // åœ–ç‰‡åœ¨ 0 zoom æ™‚çš„ baseScale èˆ‡ç½®ä¸­
      baseScale = Math.min(canvas.width / img.width, canvas.height / img.height);
      const imgDisplayW = img.width * baseScale;
      const imgDisplayH = img.height * baseScale;
      panX = (canvas.width - imgDisplayW)/2;
      panY = (canvas.height - imgDisplayH)/2;
      zoom = 1;
    }

    function imageToScreen(x,y){
      return {
        sx: panX + x * baseScale * zoom,
        sy: panY + y * baseScale * zoom
      };
    }
    function screenToImage(sx,sy){
      return {
        x: (sx - panX)/(baseScale*zoom),
        y: (sy - panY)/(baseScale*zoom)
      };
    }

    function positionHandles(){
      ensureHandles();
      corners.forEach((c,i)=>{
        const {sx,sy}=imageToScreen(c.x,c.y);
        handlesDom[i].style.left = sx+'px';
        handlesDom[i].style.top  = sy+'px';
      });
    }

    function draw(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      // ç°åº•
      ctx.fillStyle='#222'; ctx.fillRect(0,0,canvas.width,canvas.height);
      // åœ–ç‰‡
      ctx.save();
      ctx.imageSmoothingEnabled = true;
      ctx.drawImage(img, panX, panY, img.width*baseScale*zoom, img.height*baseScale*zoom);
      ctx.restore();

      // A4 guide (ä¾åœ–ç‰‡æ–¹å‘ä¾†æ±ºå®šç›´æ©«)
      const isPortrait = img.height >= img.width;
      const a4Ratio = isPortrait ? (1/Math.sqrt(2)) : Math.sqrt(2); // w/h
      const viewW = img.width*baseScale*zoom;
      const viewH = img.height*baseScale*zoom;
      let guideW, guideH;
      if ( (viewW/viewH) > a4Ratio ){
        guideH = viewH*0.9;
        guideW = guideH * a4Ratio;
      } else {
        guideW = viewW*0.9;
        guideH = guideW / a4Ratio;
      }
      const gx = panX + (viewW - guideW)/2;
      const gy = panY + (viewH - guideH)/2;
      ctx.save();
      ctx.setLineDash([8,6]);
      ctx.strokeStyle='rgba(255,210,0,0.9)';
      ctx.lineWidth=2;
      ctx.strokeRect(gx,gy,guideW,guideH);
      ctx.restore();

      // è£åˆ‡å¤šé‚Šå½¢
      ctx.save();
      ctx.beginPath();
      corners.forEach((c,i)=>{
        const {sx,sy}=imageToScreen(c.x,c.y);
        if (i===0) ctx.moveTo(sx,sy); else ctx.lineTo(sx,sy);
      });
      ctx.closePath();
      ctx.lineWidth=2;
      ctx.strokeStyle='rgba(0,136,255,0.95)';
      ctx.stroke();
      ctx.restore();

      positionHandles();
    }

    function autoDetect(){
      statusEl.textContent='(åµæ¸¬ä¸­)';
      setTimeout(()=>{
        try {
          const det = autoDetectDocumentCorners(img);
          if (det){
            corners = det;
            statusEl.textContent='(å·²åµæ¸¬)';
          } else {
            statusEl.textContent='(å¤±æ•—)';
            if (!corners) setInitialCorners();
          }
          draw();
        } catch(e){
          statusEl.textContent='(éŒ¯èª¤)';
          if (!corners) setInitialCorners();
          draw();
        }
      }, 10);
    }

    function rotate90(){
      rotation = (rotation + 90) % 360;
      // é‡æ–°å»ºç«‹è½‰å‘åœ–
      const c=document.createElement('canvas');
      const ctx2=c.getContext('2d');
      if (rotation===90 || rotation===270){
        c.width=img.height; c.height=img.width;
      } else {
        c.width=img.width; c.height=img.height;
      }
      ctx2.translate(c.width/2, c.height/2);
      ctx2.rotate(rotation*Math.PI/180);
      ctx2.drawImage(originalImage, -originalImage.width/2, -originalImage.height/2);
      img.src = c.toDataURL('image/jpeg',0.92);
    }

    function resetView(){
      computeBasePlacement();
      draw();
    }

    // äº‹ä»¶ï¼šæŒ‡æ¨™
    function pointerDown(e){
      canvas.setPointerCapture(e.pointerId);
      activePointers.set(e.pointerId,{x:e.clientX,y:e.clientY});
      // åˆ¤æ–·æ˜¯å¦é»åˆ° handle
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      let found=-1, hitDist=999;
      corners.forEach((c,i)=>{
        const {sx,sy}=imageToScreen(c.x,c.y);
        const d=Math.hypot(sx-mx, sy-my);
        if (d<40 && d<hitDist){ hitDist=d; found=i; }
      });
      if (found>=0){
        draggingHandle=found;
      } else {
        draggingHandle=-1;
      }
      lastDistance = null;
      lastMid = null;
    }
    function pointerMove(e){
      if (!activePointers.has(e.pointerId)) return;
      activePointers.set(e.pointerId, {x:e.clientX,y:e.clientY});
      const rect = canvas.getBoundingClientRect();

      if (activePointers.size===1){
        const p = activePointers.values().next().value;
        if (draggingHandle>=0){
          const sx = p.x - rect.left;
          const sy = p.y - rect.top;
            const {x,y}=screenToImage(sx,sy);
            corners[draggingHandle].x = Math.max(0, Math.min(img.width, x));
            corners[draggingHandle].y = Math.max(0, Math.min(img.height, y));
            draw();
        } else {
          // å¹³ç§» (ä½¿ç”¨ movement æœƒè¢« pointer lock å½±éŸ¿ï¼Œæ”¹è‡ªç®—)
          if (!e._lastPan){ e._lastPan={x:p.x,y:p.y}; }
          const dx = p.x - e._lastPan.x;
          const dy = p.y - e._lastPan.y;
          panX += dx;
          panY += dy;
          e._lastPan.x = p.x;
          e._lastPan.y = p.y;
          draw();
        }
      } else if (activePointers.size===2){
        // Pinch
        const pts = Array.from(activePointers.values());
        const dx = pts[0].x - pts[1].x;
        const dy = pts[0].y - pts[1].y;
        const dist = Math.hypot(dx,dy);
        const mid = { x:(pts[0].x+pts[1].x)/2, y:(pts[0].y+pts[1].y)/2 };
        if (lastDistance){
          const scaleFactor = dist / lastDistance;
          const oldZoom = zoom;
          zoom = Math.max(1, Math.min(4, zoom * scaleFactor));
          const zRatio = zoom / oldZoom;

          // ä»¥ã€Œè¢å¹•ä¸­é»ã€ç‚ºåŸºæº–èª¿æ•´ pan (ä¿æŒè§€å¯Ÿå€åŸŸ)
          // å…ˆæŠŠé€™å€‹ mid è½‰æˆ image ç›¸å°åº§æ¨™å‰çš„ screen point
          panX = mid.x - (mid.x - panX)*zRatio;
          panY = mid.y - (mid.y - panY)*zRatio;
        }
        lastDistance = dist;
        lastMid = mid;
        draw();
      }
    }
    function pointerUp(e){
      activePointers.delete(e.pointerId);
      if (activePointers.size<2){
        lastDistance=null; lastMid=null;
      }
      if (activePointers.size===0){
        draggingHandle=-1;
      }
    }

    function dblClick(e){
      // é›™æ“Šç©ºç™½è™• -> é‡è¨­è¦–åœ– + å››è§’
      computeBasePlacement();
      setInitialCorners();
      draw();
      statusEl.textContent='(å·²é‡è¨­)';
    }

    function keyEsc(e){
      if (e.key==='Escape'){
        cleanup();
        reject('cancel');
      }
    }

    function cleanup(){
      modal.classList.remove('active');
      window.removeEventListener('resize', resizeCanvas);
      canvas.removeEventListener('pointerdown', pointerDown);
      canvas.removeEventListener('pointermove', pointerMove);
      canvas.removeEventListener('pointerup', pointerUp);
      canvas.removeEventListener('pointercancel', pointerUp);
      canvas.removeEventListener('dblclick', dblClick);
      document.removeEventListener('keydown', keyEsc);
      handlesDom.forEach(h=>h && h.remove());
    }

    autoBtn.onclick = ()=>{ autoDetect(); };
    rotateBtn.onclick = ()=>{ rotate90(); };
    resetViewBtn.onclick = ()=>{ resetView(); };
    resetQuadBtn.onclick = ()=>{
      setInitialCorners();
      draw();
      statusEl.textContent='(å››è§’é‡è¨­)';
    };
    cancelBtn.onclick = ()=>{ cleanup(); reject('cancel'); };
    confirmBtn.onclick = ()=>{
      // è¨ˆç®—è¼¸å‡ºå°ºå¯¸ï¼šå–å°é‚Šè¼ƒé•·ç•¶å¯¬/é«˜
      function dist(a,b){ return Math.hypot(a.x-b.x,a.y-b.y); }
      const w = Math.min(CONFIG.FULL_MAX_DIM, Math.round(Math.max(dist(corners[0],corners[1]), dist(corners[2],corners[3]))));
      const h = Math.min(CONFIG.FULL_MAX_DIM, Math.round(Math.max(dist(corners[1],corners[2]), dist(corners[3],corners[0]))));
      const dstPts = [
        {x:0,y:0},
        {x:w-1,y:0},
        {x:w-1,y:h-1},
        {x:0,y:h-1}
      ];
      const H = computeHomography(corners, dstPts);
      if (!H){ alert('è®Šå½¢è¨ˆç®—å¤±æ•—ï¼Œè«‹å¾®èª¿å†è©¦'); return; }
      const warped = warpImage(img,H,w,h);
      applyEffect(warped, effectSelect.value);
      cleanup();
      resolve({ croppedCanvas: warped, effect: effectSelect.value, quad: corners, rotation });
    };

    // è¼‰å…¥åœ–ç‰‡
    let originalImage = new Image();
    originalImage.onload = ()=>{
      img = originalImage;
      modal.classList.add('active');
      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();
      if (!corners) setInitialCorners();
      draw();
      autoDetect();
    };
    originalImage.onerror = ()=>{ reject('img_error'); };
    originalImage.src = dataUrl;

    // ç¶äº‹ä»¶
    canvas.addEventListener('pointerdown', pointerDown);
    canvas.addEventListener('pointermove', pointerMove);
    canvas.addEventListener('pointerup', pointerUp);
    canvas.addEventListener('pointercancel', pointerUp);
    canvas.addEventListener('dblclick', dblClick);
    document.addEventListener('keydown', keyEsc);

    if (opts.initialEffect) effectSelect.value = opts.initialEffect;
  });
}

/* ----------------------------------
   åœ–ç‰‡ç¸®åœ– / åŠ å…¥åˆ—è¡¨
---------------------------------- */
function createScaledCanvas(img,maxDim){
  let w=img.width, h=img.height;
  const r=w/h;
  if (w>h){
    if (w>maxDim){ w=maxDim; h=Math.round(w/r); }
  } else {
    if (h>maxDim){ h=maxDim; w=Math.round(h*r); }
  }
  const c=document.createElement('canvas'); c.width=w; c.height=h;
  c.getContext('2d').drawImage(img,0,0,w,h);
  return c;
}
function processCroppedCanvas(canvas,effect){
  return new Promise(res=>{
    const img=new Image();
    img.onload=()=>{
      const full = createScaledCanvas(img, CONFIG.FULL_MAX_DIM);
      applyEffect(full,effect);
      const fullDataUrl = full.toDataURL('image/jpeg', CONFIG.IMAGE_QUALITY);
      const prev = createScaledCanvas(img, 260);
      const prevDataUrl = prev.toDataURL('image/jpeg', 0.7);
      res({ fullDataUrl, previewDataUrl: prevDataUrl, w:full.width, h:full.height });
    };
    img.src = canvas.toDataURL('image/jpeg',0.95);
  });
}

async function editImage(id){
  const item = images.find(i=>i.id===id);
  if (!item) return;
  try{
    const { croppedCanvas,effect,quad,rotation } = await openCropper(item.origDataUrl, {
      initialEffect:item.effect,
      initialQuad:item.quad,
      initialRotation:item.rotation
    });
    const processed = await processCroppedCanvas(croppedCanvas,effect);
    Object.assign(item, processed, { effect, quad, rotation, ts:Date.now() });
    updatePreview();
  } catch(e){
    if (e!=='cancel') console.warn(e);
  }
}

/* ----------------------------------
   ä¸Šå‚³è™•ç†
---------------------------------- */
function handleFiles(fileList){
  if (!fileList || !fileList.length) return;
  document.getElementById('loading').style.display='inline';
  const arr = Array.from(fileList).filter(f=>f.type.startsWith('image/'));
  let idx=0;
  (function next(){
    if (idx>=arr.length){
      document.getElementById('loading').style.display='none';
      return;
    }
    const f=arr[idx++];
    (async ()=>{
      try {
        const norm = await loadImageNormalized(f);
        const {croppedCanvas,effect,quad,rotation} = await openCropper(norm,{});
        const processed = await processCroppedCanvas(croppedCanvas,effect);
        images.push({
          id:Date.now().toString(36)+Math.random().toString(36).slice(2,8),
          origDataUrl:norm,
          fullDataUrl:processed.fullDataUrl,
          previewDataUrl:processed.previewDataUrl,
          w:processed.w, h:processed.h,
          effect, quad, rotation, ts:Date.now()
        });
        updatePreview();
      } catch(e){
        if (e!=='cancel') console.warn(e);
      } finally {
        next();
      }
    })();
  })();
}

document.getElementById('cameraInput').addEventListener('change', e=>{
  handleFiles(e.target.files); e.target.value='';
});
document.getElementById('fileInput').addEventListener('change', e=>{
  handleFiles(e.target.files); e.target.value='';
});

/* ----------------------------------
   UI æ›´æ–°
---------------------------------- */
function updatePreview(){
  const wrap=document.getElementById('preview');
  wrap.innerHTML='';
  images.forEach((imgObj,idx)=>{
    const div=document.createElement('div');
    div.className='thumb';
    div.innerHTML=`
      <div class="order-label">${idx+1}</div>
      <img src="${imgObj.previewDataUrl}" alt="p${idx+1}">
      <button class="remove-btn" title="åˆªé™¤">Ã—</button>
    `;
    div.querySelector('.remove-btn').onclick=(ev)=>{
      ev.stopPropagation();
      images = images.filter(x=>x.id!==imgObj.id);
      updatePreview();
    };
    div.onclick=()=>editImage(imgObj.id);
    wrap.appendChild(div);
  });
  document.getElementById('storageInfo').textContent = `ç›®å‰åœ–ç‰‡æ•¸é‡ï¼š${images.length}`;
}

function clearAllImages(){
  if (confirm('ç¢ºå®šåˆªé™¤å…¨éƒ¨åœ–ç‰‡ï¼Ÿ')){
    images=[];
    updatePreview();
  }
}
function triggerCamera(){ document.getElementById('cameraInput').click(); }
function triggerFile(){ document.getElementById('fileInput').click(); }

/* ----------------------------------
   PDF ç”¢ç”Ÿ
---------------------------------- */
function getPdfFilename(){
  const d=new Date(), pad=n=>String(n).padStart(2,'0');
  return `${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}_scan.pdf`;
}
function generatePDF(){
  if (!images.length){ alert('è«‹å…ˆåŠ å…¥åœ–ç‰‡'); return; }
  document.getElementById('loading').style.display='inline';
  try{
    const firstLandscape = images[0].w > images[0].h;
    const pdf = new jsPDF({
      unit:'pt', format:'a4', orientation:firstLandscape?'landscape':'portrait'
    });
    const A4W=595.28, A4H=841.89;
    images.forEach((im,idx)=>{
      if (idx>0){
        const isL = im.w>im.h;
        pdf.addPage('a4', isL?'landscape':'portrait');
      }
      const pageW = im.w>im.h ? A4H : A4W;
      const pageH = im.w>im.h ? A4W : A4H;
      const ratio = Math.min(pageW/im.w, pageH/im.h);
      const w=im.w*ratio, h=im.h*ratio;
      pdf.addImage(im.fullDataUrl, 'JPEG', (pageW-w)/2, (pageH-h)/2, w, h);
    });
    pdf.save(getPdfFilename());
  } catch(e){
    console.error(e);
    alert('ç”¢ç”Ÿ PDF ç™¼ç”ŸéŒ¯èª¤');
  } finally {
    document.getElementById('loading').style.display='none';
  }
}
</script>
</body>
</html>
