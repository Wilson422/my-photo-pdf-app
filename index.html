<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>文件拍照轉 PDF（自動裁切＋強化對比）</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 2em; }
    .preview { display: flex; flex-wrap: wrap; gap: 10px; margin: 1em 0; }
    .preview-item { position: relative; }
    .preview-item img { width: 120px; border: 1px solid #aaa; border-radius: 4px; }
    .remove-btn {
      position: absolute; top: 2px; right: 2px;
      background: rgba(255,0,0,0.8); color: #fff; border: none; border-radius: 3px;
      cursor: pointer; font-size: 12px; padding: 2px 6px;
    }
    .actions { margin-bottom: 1em; }
    button { font-size: 1em; margin-right: .5em; }
    #loading { display:none; color: #009; font-weight: bold; }
  </style>
  <!-- 重要：載入 OpenCV.js -->
  <script async src="https://docs.opencv.org/4.x/opencv.js" type="text/javascript"></script>
</head>
<body>
  <h2>📄 文件拍照轉 PDF（自動裁切＋強化對比）</h2>
  <div class="actions">
    <input type="file" accept="image/*" capture="environment" id="cameraInput" style="display:none">
    <input type="file" accept="image/*" multiple id="fileInput" style="display:none">
    <button onclick="document.getElementById('cameraInput').click()">📷 拍照</button>
    <button onclick="document.getElementById('fileInput').click()">🖼️ 選照片</button>
    <button onclick="generatePDF()">🧾 產生 PDF</button>
    <span id="loading">圖片處理中，請稍候...</span>
  </div>
  <div class="preview" id="preview"></div>

  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
  <script>
    const { jsPDF } = window.jspdf;
    let images = [];
    let cvReady = false;

    // 等待 OpenCV 載入
    function onOpenCvReady() {
      cvReady = true;
    }
    window.Module = { onRuntimeInitialized: onOpenCvReady };

    // 影像處理核心：自動裁切＋灰階＋對比強化
    async function processImageAutoCropAndEnhance(img) {
      return new Promise((resolve) => {
        // 建立 canvas 取得像素
        const canvas = document.createElement('canvas');
        canvas.width = img.naturalWidth || img.width;
        canvas.height = img.naturalHeight || img.height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

        // 取得 imageData
        let src = cv.imread(canvas);
        let dst = new cv.Mat();
        let gray = new cv.Mat();
        let blurred = new cv.Mat();
        let edged = new cv.Mat();

        // 灰階
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);

        // 模糊降噪
        cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0, 0, cv.BORDER_DEFAULT);

        // 邊緣偵測
        cv.Canny(blurred, edged, 60, 150);

        // 輪廓偵測
        let contours = new cv.MatVector();
        let hierarchy = new cv.Mat();
        cv.findContours(edged, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

        // 找最大四邊形
        let maxArea = 0, pageContour = null;
        for (let i = 0; i < contours.size(); i++) {
          let cnt = contours.get(i);
          let peri = cv.arcLength(cnt, true);
          let approx = new cv.Mat();
          cv.approxPolyDP(cnt, approx, 0.02 * peri, true);
          if (approx.rows === 4) {
            let area = cv.contourArea(cnt);
            if (area > maxArea) {
              maxArea = area;
              pageContour = approx;
            } else {
              approx.delete();
            }
          } else {
            approx.delete();
          }
          cnt.delete();
        }

        let resultCanvas = document.createElement('canvas');
        let resultCtx = resultCanvas.getContext('2d');

        // 若找到四邊形，進行透視校正
        if (pageContour) {
          // 四個點排序: 左上、右上、右下、左下
          let pts = [];
          for (let i = 0; i < 4; i++) {
            pts.push({ x: pageContour.intPtr(i, 0)[0], y: pageContour.intPtr(i, 0)[1] });
          }
          pts.sort((a, b) => a.x + a.y - (b.x + b.y));
          let [tl, br] = [pts[0], pts[3]];
          let [tr, bl] = pts[1].x > pts[2].x ? [pts[1], pts[2]] : [pts[2], pts[1]];

          // 寬高
          let widthA = Math.hypot(br.x - bl.x, br.y - bl.y);
          let widthB = Math.hypot(tr.x - tl.x, tr.y - tl.y);
          let maxWidth = Math.max(widthA, widthB);

          let heightA = Math.hypot(tr.x - br.x, tr.y - br.y);
          let heightB = Math.hypot(tl.x - bl.x, tl.y - bl.y);
          let maxHeight = Math.max(heightA, heightB);

          // 來源點與目標點
          let srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
            tl.x, tl.y,
            tr.x, tr.y,
            br.x, br.y,
            bl.x, bl.y
          ]);
          let dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
            0, 0,
            maxWidth - 1, 0,
            maxWidth - 1, maxHeight - 1,
            0, maxHeight - 1
          ]);
          let M = cv.getPerspectiveTransform(srcTri, dstTri);

          // 透視轉換
          let warped = new cv.Mat();
          cv.warpPerspective(gray, warped, M, new cv.Size(maxWidth, maxHeight), cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());

          // 強化對比（二值化）
          cv.adaptiveThreshold(warped, dst, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 19, 9);

          // 畫回 canvas
          cv.imshow(resultCanvas, dst);

          // 清理
          warped.delete(); srcTri.delete(); dstTri.delete(); M.delete();
          pageContour.delete();
        } else {
          // 若沒找到文件輪廓，直接灰階+強化對比
          cv.adaptiveThreshold(gray, dst, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 19, 9);
          cv.imshow(resultCanvas, dst);
        }

        // 輸出 DataURL
        resolve(resultCanvas.toDataURL('image/jpeg', 0.92));

        // 釋放記憶體
        src.delete(); dst.delete(); gray.delete(); blurred.delete(); edged.delete(); contours.delete(); hierarchy.delete();
      });
    }

    async function handleFiles(files) {
      if (!cvReady) {
        alert("OpenCV 載入中，請稍候再試！");
        return;
      }
      document.getElementById('loading').style.display = '';
      for (let file of files) {
        if (!file.type.startsWith('image/')) continue;
        await new Promise((resolve) => {
          const reader = new FileReader();
          reader.onload = async e => {
            const img = new Image();
            img.onload = async () => {
              // 處理圖片
              const processedDataUrl = await processImageAutoCropAndEnhance(img);
              images.push(processedDataUrl);
              updatePreview();
              resolve();
            };
            img.src = e.target.result;
          };
          reader.readAsDataURL(file);
        });
      }
      document.getElementById('loading').style.display = 'none';
    }

    document.getElementById('cameraInput').addEventListener('change', e => {
      handleFiles(e.target.files);
      e.target.value = '';
    });
    document.getElementById('fileInput').addEventListener('change', e => {
      handleFiles(e.target.files);
      e.target.value = '';
    });

    function updatePreview() {
      const preview = document.getElementById('preview');
      preview.innerHTML = '';
      images.forEach((src, i) => {
        const div = document.createElement('div');
        div.className = 'preview-item';
        const img = document.createElement('img');
        img.src = src;
        const btn = document.createElement('button');
        btn.className = 'remove-btn';
        btn.textContent = '✖';
        btn.onclick = () => {
          images.splice(i, 1);
          updatePreview();
        };
        div.appendChild(img);
        div.appendChild(btn);
        preview.appendChild(div);
      });
    }

    function generatePDF() {
      if (images.length === 0) {
        alert('請先新增照片');
        return;
      }
      const pdf = new jsPDF({ unit: 'pt', format: 'a4' });
      let first = true;
      images.forEach((src, idx) => {
        const img = new Image();
        img.onload = () => {
          let pdfW = pdf.internal.pageSize.getWidth();
          let pdfH = pdf.internal.pageSize.getHeight();
          let ratio = Math.min(pdfW / img.width, pdfH / img.height);
          let w = img.width * ratio, h = img.height * ratio;
          let x = (pdfW - w) / 2, y = (pdfH - h) / 2;
          if (!first) pdf.addPage();
          pdf.addImage(img, 'JPEG', x, y, w, h);
          if (idx === images.length - 1) {
            pdf.save('document.pdf');
          }
        };
        img.src = src;
        first = false;
      });
    }
  </script>
</body>
</html>
