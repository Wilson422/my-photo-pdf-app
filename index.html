<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>文件拍照轉 PDF（自動偵測 + 邊中拖曳 + 正確方向 + 手動旋轉 + 可再次裁切）</title>
<style>
  body { font-family: Arial,"Noto Sans TC",sans-serif; margin:1.2em; background:#fff; }
  h2 { margin-top:0; }
  .actions { display:flex; flex-wrap:wrap; gap:.5em; align-items:center; margin-bottom:.6em; }
  .actions input[type=file]{ display:none; }
  .actions button { background:#f5f5f5; border:none; padding:.5em .9em; font-size:.92em; border-radius:8px; cursor:pointer; }
  .actions button:hover { background:#eaeaea; }
  button.danger { background:#ffecec; color:#b80000; }
  #loading { display:none; font-size:.85em; color:#004; font-weight:bold; margin-left:.6em; }
  #storageInfo { font-size:.88em; color:#666; margin:.4em 0; }
  #preview { display:flex; flex-wrap:wrap; gap:10px; margin-top:.6em; }

  .thumb { position:relative; width:140px; background:#fafafa; padding:8px 8px 34px; box-sizing:border-box; border:2px solid transparent; border-radius:8px; user-select:none; cursor:pointer; }
  .thumb:hover { border-color:#1976d2; }
  .thumb img { width:100%; height:auto; display:block; border:1px solid #ddd; border-radius:6px; background:#fff; object-fit:contain; }
  .order-label { position:absolute; top:8px; left:8px; background:#1976d2; color:#fff; font-size:12px; padding:4px 7px; border-radius:6px; font-weight:bold; opacity:.95; }
  .remove-btn { position:absolute; top:8px; right:8px; background:rgba(255,0,0,.9); color:#fff; border:none; border-radius:6px; font-size:12px; padding:4px 7px; cursor:pointer; }
  .move-bar { position:absolute; bottom:8px; left:8px; right:8px; display:flex; justify-content:center; gap:8px; }
  .move-btn { background:#fff; border:1px solid #ccc; font-size:13px; padding:6px 8px; border-radius:6px; cursor:pointer; }
  .move-btn:hover { background:#f6f6f6; }

  #cropperModal { position:fixed; inset:0; background:rgba(0,0,0,0.72); display:none; align-items:center; justify-content:center; z-index:9999; }
  #cropperModal .modal-content { background:#fff; width:95vw; max-width:1100px; border-radius:12px; max-height:86vh; overflow:auto; padding:14px; box-sizing:border-box; display:flex; flex-direction:column; align-items:center; }
  #cropperTip { font-size:.9em; color:#333; margin-bottom:8px; text-align:center; }
  .canvas-wrapper { position:relative; display:inline-block; background:#fafafa; border-radius:8px; }
  canvas#cropperCanvas { display:block; border-radius:6px; background:#fff; touch-action:none; -webkit-user-select:none; user-select:none; }

  .handle, .edge-handle {
    position:absolute; width:28px; height:28px; margin-left:-14px; margin-top:-14px;
    background:#1976d2; border-radius:50%; border:3px solid #fff;
    box-shadow:0 2px 6px rgba(0,0,0,0.35); z-index:60; touch-action:none; cursor:grab;
  }
  .handle:active, .edge-handle:active { cursor:grabbing; }

  .controls { margin-top:10px; display:flex; gap:.6em; align-items:center; flex-wrap:wrap; }
  select { padding:.35em .6em; border-radius:6px; border:1px solid #ccc; background:#fff; }
  .guide { font-size:.82em; color:#666; margin-top:6px; text-align:center; }
  #autoDetectStatus { font-size:.75em; color:#555; }
  #cropperBtns { margin-top:12px; display:flex; gap:.6em; flex-wrap:wrap; }
  #cropperBtns button { padding:.5em .8em; border-radius:8px; border:none; background:#f5f5f5; cursor:pointer; }
  #cropperBtns button:hover { background:#eaeaea; }

  /* LINE 瀏覽器提醒條 */
  #lineWarningBar {
    display:none;
    position:fixed;
    top:0; left:0; right:0;
    background:#fffbcc;
    color:#444;
    font-size:.85em;
    padding:.55em .9em .6em;
    border-bottom:1px solid #e2d885;
    z-index:10000;
    line-height:1.3;
  }
  #lineWarningBar button {
    margin-left:.8em;
    background:#fff3a0;
    border:1px solid #d4c360;
    padding:.25em .6em;
    font-size:.75em;
    border-radius:4px;
    cursor:pointer;
  }
  #lineWarningBar button:hover { background:#ffe970; }

  body.has-line-warning { padding-top:54px; }

  @media (max-width:560px){
    .thumb { width:30vw; max-width:150px; padding-bottom:34px; }
    .handle, .edge-handle { width:34px; height:34px; margin-left:-17px; margin-top:-17px; }
    #cropperModal .modal-content { padding:10px; }
    #lineWarningBar { font-size:.78em; }
  }
</style>
<script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
</head>
<body>
<div id="lineWarningBar">
  偵測到您正透過 LINE 內建瀏覽器使用，此環境可能導致拍照/檔案處理或儲存不穩定。
  建議：使用右上角「在外部瀏覽器開啟」(Android) 或右上角分享 -> 在 Safari 開啟 (iOS)。
  <button onclick="document.getElementById('lineWarningBar').style.display='none'; document.body.classList.remove('has-line-warning');">關閉</button>
</div>

<h2>📄 文件拍照轉 PDF（自動偵測 + 邊中拖曳 + 正確方向 + 可再次裁切）</h2>

<div class="actions">
  <input type="file" accept="image/*" capture="environment" id="cameraInput">
  <input type="file" accept="image/*" multiple id="fileInput">
  <button onclick="triggerCamera()">📷 拍照</button>
  <button onclick="triggerFile()">🖼️ 選照片</button>
  <button onclick="generatePDF()">🧾 產生 PDF</button>
  <button class="danger" onclick="clearAllImages()">🗑️ 清除全部</button>
  <span id="loading">處理中...</span>
</div>

<div id="storageInfo">目前圖片數量：0</div>
<div id="preview"></div>

<div id="cropperModal" role="dialog" aria-modal="true">
  <div class="modal-content">
    <div id="cropperTip">
      拖曳四角/邊中藍點調整；雙擊畫面重設角點。自動偵測不準可重跑或手動微調。若方向不正確請用旋轉按鈕。 (可重複編輯：裁切後點縮圖再進來)
    </div>

    <div id="canvasContainer" class="canvas-wrapper" style="touch-action:none;">
      <canvas id="cropperCanvas" width="800" height="600"></canvas>
    </div>

    <div class="controls">
      <label>效果：
        <select id="effectSelect">
          <option value="original">原色</option>
          <option value="gray">灰階</option>
          <option value="bw">黑白（高對比）</option>
        </select>
      </label>
      <button id="autoDetectBtn" title="重新自動找四角">🔍 重跑偵測</button>
      <button id="rotateLeftBtn" title="逆時針 90°">↺ 90°</button>
      <button id="rotateRightBtn" title="順時針 90°">↻ 90°</button>
      <span id="autoDetectStatus"></span>
    </div>

    <div class="guide">若偵測不準：改善光線與背景對比 / 使用旋轉 / 手動拖曳調整。完成後「確定裁切」。</div>

    <div id="cropperBtns">
      <button id="cropResetBtn">重設四角</button>
      <button id="cropConfirmBtn">確定裁切</button>
      <button id="cropCancelBtn">取消</button>
    </div>
  </div>
</div>

<script>
/* 基本設定 */
const CONFIG = { FULL_MAX_DIM: 2000, PREVIEW_MAX_WIDTH: 420, IMAGE_QUALITY: 0.9 };
let images = [];
const { jsPDF } = window.jspdf || {};

/* ========== LINE 內建瀏覽器偵測 / 提醒 ========== */
function detectLineInApp(){
  const ua = navigator.userAgent || '';
  // 常見 UA 片段： Line/ 或 LINE/
  if (/ Line\/|; Line\//i.test(ua) || /\bLine\b/i.test(ua)){
    const bar = document.getElementById('lineWarningBar');
    if (bar){
      bar.style.display='block';
      document.body.classList.add('has-line-warning');
      // 亦可額外 alert（如不想重複可註解掉）
      // alert('偵測到 LINE 內建瀏覽器。建議使用系統預設瀏覽器 (Safari/Chrome) 開啟以確保功能正常。');
    }
  }
}

/* ========== ORIENT: 讀取與修正方向 ========== */
async function loadImageNormalized(file){
  const arrayBuffer = await file.arrayBuffer();
  let blob = file;
  if (self.createImageBitmap){
    try {
      const imgBitmap = await createImageBitmap(new Blob([arrayBuffer]), { imageOrientation: 'from-image' });
      const c = document.createElement('canvas');
      c.width = imgBitmap.width;
      c.height = imgBitmap.height;
      const ctx = c.getContext('2d');
      ctx.drawImage(imgBitmap,0,0);
      return c.toDataURL('image/jpeg', CONFIG.IMAGE_QUALITY);
    } catch(e){}
  }
  const orientation = getExifOrientation(arrayBuffer);
  const dataUrl = await blobToDataURL(new Blob([arrayBuffer], { type: file.type || 'image/jpeg'}));
  if (orientation === 1) return dataUrl;
  return await fixImageOrientationByOrientation(dataUrl, orientation);
}
function blobToDataURL(blob){
  return new Promise((resolve,reject)=>{
    const fr = new FileReader();
    fr.onload = e => resolve(e.target.result);
    fr.onerror = reject;
    fr.readAsDataURL(blob);
  });
}
function getExifOrientation(arrayBuffer){
  try {
    const view = new DataView(arrayBuffer);
    if (view.getUint16(0,false)!==0xFFD8) return 1;
    let offset=2;
    while (offset < view.byteLength){
      const marker=view.getUint16(offset,false); offset+=2;
      if (marker === 0xFFE1){
        const size=view.getUint16(offset,false);
        const exifHeader=offset+2;
        if (view.getUint32(exifHeader,false)!==0x45786966) return 1;
        const tiff=exifHeader+6;
        const endian=view.getUint16(tiff,false);
        const little=endian===0x4949;
        if (view.getUint16(tiff+2,little)!==0x002A) return 1;
        let ifdOffset=view.getUint32(tiff+4,little)+tiff;
        const entries=view.getUint16(ifdOffset,little);
        for (let i=0;i<entries;i++){
          const entry=ifdOffset+2+i*12;
            if (view.getUint16(entry,little)===0x0112){
              return view.getUint16(entry+8,little) || 1;
            }
        }
        return 1;
      } else if (marker === 0xFFDA){
        break;
      } else {
        const size=view.getUint16(offset,false);
        offset+=size;
      }
    }
  } catch(_){}
  return 1;
}
function fixImageOrientationByOrientation(dataUrl, orientation){
  return new Promise(resolve=>{
    if (orientation===1) return resolve(dataUrl);
    const img=new Image();
    img.onload=()=>{
      const w=img.naturalWidth, h=img.naturalHeight;
      const c=document.createElement('canvas');
      const ctx=c.getContext('2d');
      switch(orientation){
        case 2: c.width=w; c.height=h; ctx.translate(w,0); ctx.scale(-1,1); break;
        case 3: c.width=w; c.height=h; ctx.translate(w,h); ctx.rotate(Math.PI); break;
        case 4: c.width=w; c.height=h; ctx.translate(0,h); ctx.scale(1,-1); break;
        case 5: c.width=h; c.height=w; ctx.rotate(0.5*Math.PI); ctx.scale(1,-1); break;
        case 6: c.width=h; c.height=w; ctx.rotate(0.5*Math.PI); ctx.translate(0,-h); break;
        case 7: c.width=h; c.height=w; ctx.rotate(0.5*Math.PI); ctx.translate(w,-h); ctx.scale(-1,1); break;
        case 8: c.width=h; c.height=w; ctx.rotate(-0.5*Math.PI); ctx.translate(-h,0); break;
        default: c.width=w; c.height=h;
      }
      ctx.drawImage(img,0,0);
      resolve(c.toDataURL('image/jpeg', CONFIG.IMAGE_QUALITY));
    };
    img.onerror=()=>resolve(dataUrl);
    img.src=dataUrl;
  });
}

/* ========== 自動偵測四角（同原邏輯） ========== */
function autoDetectDocumentCorners(img){
  const MAX_SIDE=800;
  const scale=Math.min(1, MAX_SIDE/Math.max(img.width,img.height));
  const sw=Math.round(img.width*scale), sh=Math.round(img.height*scale);
  const c=document.createElement('canvas'); c.width=sw; c.height=sh;
  const ctx=c.getContext('2d'); ctx.drawImage(img,0,0,sw,sh);
  const data=ctx.getImageData(0,0,sw,sh).data;
  const gray=new Uint8ClampedArray(sw*sh);
  for (let i=0,j=0;i<data.length;i+=4,j++) gray[j]=(0.299*data[i]+0.587*data[i+1]+0.114*data[i+2])|0;

  const blur=new Uint8ClampedArray(sw*sh);
  for (let y=0;y<sh;y++){
    for (let x=0;x<sw;x++){
      let sum=0,cnt=0;
      for (let ky=-1;ky<=1;ky++){
        const yy=y+ky; if (yy<0||yy>=sh) continue;
        for (let kx=-1;kx<=1;kx++){
          const xx=x+kx; if (xx<0||xx>=sw) continue;
          sum+=gray[yy*sw+xx]; cnt++;
        }
      }
      blur[y*sw+x]=(sum/cnt)|0;
    }
  }
  const gxK=[-1,0,1,-2,0,2,-1,0,1], gyK=[-1,-2,-1,0,0,0,1,2,1];
  const mag=new Float32Array(sw*sh);
  for (let y=1;y<sh-1;y++){
    for (let x=1;x<sw-1;x++){
      let gx=0,gy=0,idx=0;
      for (let ky=-1;ky<=1;ky++){
        for (let kx=-1;kx<=1;kx++){
          const v=blur[(y+ky)*sw+(x+kx)];
          gx+=v*gxK[idx]; gy+=v*gyK[idx]; idx++;
        }
      }
      mag[y*sw+x]=Math.hypot(gx,gy);
    }
  }
  let sum=0,count=0;
  for (let i=0;i<mag.length;i++){ if(mag[i]>0){ sum+=mag[i]; count++; } }
  const mean=sum/(count||1), thresh=mean*1.3;
  const edge=new Uint8Array(sw*sh);
  for (let i=0;i<mag.length;i++) edge[i]=mag[i]>thresh?1:0;
  const edge2=new Uint8Array(edge);
  for (let y=1;y<sh-1;y++){
    for (let x=1;x<sw-1;x++){
      if (edge[y*sw+x]) continue;
      outer: for (let ky=-1;ky<=1;ky++){
        for (let kx=-1;kx<=1;kx++){
          if (edge[(y+ky)*sw+(x+kx)]){ edge2[y*sw+x]=1; break outer; }
        }
      }
    }
  }
  const pts=[];
  for (let y=0;y<sh;y++)
    for (let x=0;x<sw;x++)
      if (edge2[y*sw+x]) pts.push({x,y});
  if (pts.length<50) return null;
  pts.sort((a,b)=>a.x===b.x? a.y-b.y : a.x-b.x);
  function cross(o,a,b){ return (a.x-o.x)*(b.y-o.y)-(a.y-o.y)*(b.x-o.x); }
  const lower=[], upper=[];
  for (const p of pts){
    while (lower.length>=2 && cross(lower[lower.length-2], lower[lower.length-1], p)<=0) lower.pop();
    lower.push(p);
  }
  for (let i=pts.length-1;i>=0;i--){
    const p=pts[i];
    while (upper.length>=2 && cross(upper[upper.length-2], upper[upper.length-1], p)<=0) upper.pop();
    upper.push(p);
  }
  upper.pop(); lower.pop();
  const hull=lower.concat(upper);
  if (hull.length<4) return null;
  let tl,tr,br,bl;
  let minSum=Infinity,maxSum=-Infinity,minDiff=Infinity,maxDiff=-Infinity;
  for (const p of hull){
    const s=p.x+p.y, d=p.x-p.y;
    if (s<minSum){ minSum=s; tl=p; }
    if (s>maxSum){ maxSum=s; br=p; }
    if (d>maxDiff){ maxDiff=d; tr=p; }
    if (d<minDiff){ minDiff=d; bl=p; }
  }
  if(!tl||!tr||!br||!bl) return null;
  const invScale=1/scale;
  const quad=[tl,tr,br,bl].map(p=>({x:p.x*invScale,y:p.y*invScale}));
  function polyArea(q){
    let a=0;
    for (let i=0;i<q.length;i++){
      const p1=q[i], p2=q[(i+1)%q.length];
      a+=p1.x*p2.y - p2.x*p1.y;
    }
    return Math.abs(a)/2;
  }
  if (polyArea(quad) < img.width*img.height*0.1) return null;
  return quad;
}

/* 線性代數 / 影像變形 */
function solveLinearSystem(A,b){
  const n=A.length; const M=A.map((r,i)=>r.slice().concat(b[i]));
  for (let k=0;k<n;k++){
    let im=k;
    for (let i=k+1;i<n;i++) if (Math.abs(M[i][k])>Math.abs(M[im][k])) im=i;
    if (Math.abs(M[im][k])<1e-12) return null;
    [M[k],M[im]]=[M[im],M[k]];
    const piv=M[k][k];
    for (let j=k;j<=n;j++) M[k][j]/=piv;
    for (let i=0;i<n;i++) if (i!==k){
      const f=M[i][k];
      for (let j=k;j<=n;j++) M[i][j]-=f*M[k][j];
    }
  }
  return M.map(r=>r[n]);
}
function computeHomography(srcPts,dstPts){
  const A=[], b=[];
  for (let i=0;i<4;i++){
    const {x,y}=srcPts[i], {x:u,y:v}=dstPts[i];
    A.push([x,y,1,0,0,0,-u*x,-u*y]); b.push(u);
    A.push([0,0,0,x,y,1,-v*x,-v*y]); b.push(v);
  }
  const h=solveLinearSystem(A,b); if(!h) return null;
  return [[h[0],h[1],h[2]],[h[3],h[4],h[5]],[h[6],h[7],1]];
}
function invert3x3(m){
  const a=m[0][0],b=m[0][1],c=m[0][2], d=m[1][0],e=m[1][1],f=m[1][2], g=m[2][0],h=m[2][1],i=m[2][2];
  const A=e*i-f*h,B=c*h-b*i,C=b*f-c*e, D=f*g-d*i,E=a*i-c*g,F=c*d-a*f, G=d*h-e*g,H=b*g-a*h,I=a*e-b*d;
  const det=a*A+b*D+c*G; if (Math.abs(det)<1e-12) return null;
  const inv=1/det;
  return [[A*inv,B*inv,C*inv],[D*inv,E*inv,F*inv],[G*inv,H*inv,I*inv]];
}
function warpImageWithHomography(srcCanvas,H,dstW,dstH){
  const dst=document.createElement('canvas'); dst.width=dstW; dst.height=dstH;
  const dstCtx=dst.getContext('2d'), srcCtx=srcCanvas.getContext('2d');
  const srcW=srcCanvas.width, srcH=srcCanvas.height;
  const srcData=srcCtx.getImageData(0,0,srcW,srcH).data;
  const dstImg=dstCtx.createImageData(dstW,dstH); const dstData=dstImg.data;
  const Hinv=invert3x3(H); if(!Hinv){ dstCtx.drawImage(srcCanvas,0,0,dstW,dstH); return dst; }
  for (let y=0;y<dstH;y++){
    for (let x=0;x<dstW;x++){
      const denom=Hinv[2][0]*x + Hinv[2][1]*y + Hinv[2][2];
      if (!denom) continue;
      const sx=(Hinv[0][0]*x + Hinv[0][1]*y + Hinv[0][2])/denom;
      const sy=(Hinv[1][0]*x + Hinv[1][1]*y + Hinv[1][2])/denom;
      let r=255,g=255,b=255,a=255;
      if (sx>=0&&sy>=0&&sx<srcW&&sy<srcH){
        const x0=Math.floor(sx), y0=Math.floor(sy);
        const x1=Math.min(x0+1, srcW-1), y1=Math.min(y0+1, srcH-1);
        const dx=sx-x0, dy=sy-y0;
        const idx00=(y0*srcW+x0)*4, idx10=(y0*srcW+x1)*4;
        const idx01=(y1*srcW+x0)*4, idx11=(y1*srcW+x1)*4;
        function lerp(a,b,t){ return a+(b-a)*t; }
        function pick(idx){ return [srcData[idx],srcData[idx+1],srcData[idx+2],srcData[idx+3]]; }
        const p00=pick(idx00), p10=pick(idx10), p01=pick(idx01), p11=pick(idx11);
        const p0=p00.map((v,i)=>lerp(v,p10[i],dx));
        const p1=p01.map((v,i)=>lerp(v,p11[i],dx));
        const p=p0.map((v,i)=>lerp(v,p1[i],dy));
        [r,g,b,a]=p;
      }
      const di=(y*dstW+x)*4;
      dstData[di]=r; dstData[di+1]=g; dstData[di+2]=b; dstData[di+3]=a;
    }
  }
  dstCtx.putImageData(dstImg,0,0);
  return dst;
}
function applyEffect(canvas,effect){
  if (!canvas || effect==='original') return;
  const ctx=canvas.getContext('2d');
  const imgd=ctx.getImageData(0,0,canvas.width,canvas.height);
  const d=imgd.data;
  for (let i=0;i<d.length;i+=4){
    const r=d[i],g=d[i+1],b=d[i+2];
    const lum=0.299*r+0.587*g+0.114*b;
    d[i]=d[i+1]=d[i+2]=lum;
  }
  if (effect==='bw'){
    const hist=new Array(256).fill(0);
    for (let i=0;i<d.length;i+=4) hist[d[i]]++;
    const total=canvas.width*canvas.height;
    let sum=0; for (let t=0;t<256;t++) sum+=t*hist[t];
    let wB=0,sumB=0,varMax=0,th=0;
    for (let t=0;t<256;t++){
      wB+=hist[t]; if(!wB) continue;
      const wF=total-wB; if(!wF) break;
      sumB+=t*hist[t];
      const mB=sumB/wB, mF=(sum-sumB)/wF;
      const v=wB*wF*(mB-mF)*(mB-mF);
      if (v>varMax){ varMax=v; th=t; }
    }
    for (let i=0;i<d.length;i+=4){
      const v=d[i]>th?255:0;
      d[i]=d[i+1]=d[i+2]=v;
    }
  }
  ctx.putImageData(imgd,0,0);
}

/* ========= 裁切 UI（新增：初始值、再次裁切、保留 rotation/quad） =========
   openCropper(dataUrl, options)
   options: { initialEffect, initialQuad, initialRotation }
   resolve: { croppedCanvas, effect, quad, rotation }
*/
function openCropper(dataUrl, options={}){
  const { initialEffect, initialQuad, initialRotation } = options;
  return new Promise((resolve,reject)=>{
    const modal=document.getElementById('cropperModal');
    const canvas=document.getElementById('cropperCanvas');
    const wrapper=document.getElementById('canvasContainer');
    const statusEl=document.getElementById('autoDetectStatus');
    const rotateLeftBtn=document.getElementById('rotateLeftBtn');
    const rotateRightBtn=document.getElementById('rotateRightBtn');
    const effectSelect=document.getElementById('effectSelect');
    if (initialEffect){
      effectSelect.value = initialEffect;
    } else {
      effectSelect.value = 'original';
    }

    let ctx=canvas.getContext('2d');
    modal.style.display='flex';

    const baseImg=new Image();
    let workingCanvas=null;
    let workingImg=new Image();
    let rotation=0;
    let pendingInitialQuad = null;

    let imgDraw={dx:0,dy:0,dw:0,dh:0,scale:1};
    let handles=[];
    let cornerEls=[], edgeEls=[];
    let autoDone=false;

    const EDGE_MAP=[
      { a:0,b:1 },
      { a:1,b:2 },
      { a:2,b:3 },
      { a:3,b:0 }
    ];

    function ensureCornerEls(){
      for (let i=0;i<4;i++){
        if (!cornerEls[i]){
          const el=document.createElement('div');
          el.className='handle'; el.dataset.type='corner'; el.dataset.idx=i;
            el.addEventListener('pointerdown', ev=>ev.preventDefault());
          wrapper.appendChild(el);
          cornerEls[i]=el;
        }
      }
    }
    function ensureEdgeEls(){
      for (let i=0;i<4;i++){
        if (!edgeEls[i]){
          const el=document.createElement('div');
          el.className='edge-handle'; el.dataset.type='edge'; el.dataset.idx=i;
          el.addEventListener('pointerdown', ev=>ev.preventDefault());
          wrapper.appendChild(el);
          edgeEls[i]=el;
        }
      }
    }
    function positionCornerEls(){
      for (let i=0;i<4;i++){
        const el=cornerEls[i];
        const px=imgDraw.dx + handles[i].u * imgDraw.dw;
        const py=imgDraw.dy + handles[i].v * imgDraw.dh;
        el.style.left=px+'px';
        el.style.top =py+'px';
      }
    }
    function updateEdgeHandlePositions(){
      for (let i=0;i<4;i++){
        const {a,b}=EDGE_MAP[i];
        const ax=imgDraw.dx + handles[a].u*imgDraw.dw;
        const ay=imgDraw.dy + handles[a].v*imgDraw.dh;
        const bx=imgDraw.dx + handles[b].u*imgDraw.dw;
        const by=imgDraw.dy + handles[b].v*imgDraw.dh;
        edgeEls[i].style.left=((ax+bx)/2)+'px';
        edgeEls[i].style.top =((ay+by)/2)+'px';
      }
    }
    function redraw(){
      ctx.save(); ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,canvas.width,canvas.height); ctx.restore();
      ctx.drawImage(workingImg,0,0,workingImg.width,workingImg.height, imgDraw.dx,imgDraw.dy,imgDraw.dw,imgDraw.dh);
      ctx.lineWidth=2; ctx.strokeStyle='rgba(25,118,210,0.95)';
      ctx.beginPath();
      for (let i=0;i<4;i++){
        const x=imgDraw.dx + handles[i].u*imgDraw.dw;
        const y=imgDraw.dy + handles[i].v*imgDraw.dh;
        if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.closePath(); ctx.stroke();
    }
    function setDefaultHandles(){
      const inset=0.06;
      handles=[
        {u:inset, v:inset},
        {u:1-inset, v:inset},
        {u:1-inset, v:1-inset},
        {u:inset, v:1-inset}
      ];
      positionCornerEls(); updateEdgeHandlePositions(); redraw();
    }
    function setHandlesByQuad(quad){
      handles = quad.map(p=>({ u: p.x / workingImg.width, v: p.y / workingImg.height }));
      positionCornerEls(); updateEdgeHandlePositions(); redraw();
    }

    async function runAutoDetect(){
      statusEl.textContent='偵測中...';
      await new Promise(r=>setTimeout(r,16));
      try {
        const tempImg = new Image();
        tempImg.onload=()=>{
          const quad=autoDetectDocumentCorners(tempImg);
          if (quad){
            setHandlesByQuad(quad);
            statusEl.textContent='已自動偵測 ✔';
            autoDone=true;
          } else {
            statusEl.textContent='偵測失敗，已預設';
            if(!autoDone) setDefaultHandles();
          }
        };
        tempImg.src = workingImg.src;
      } catch(e){
        console.warn(e);
        statusEl.textContent='偵測錯誤，已預設';
        if(!autoDone) setDefaultHandles();
      }
    }

    function layoutWorkingImage(){
      const winW=Math.min(window.innerWidth*0.92, 1200);
      const winH=Math.min(window.innerHeight*0.7, 1100);
      const fitScale=Math.min(winW/workingImg.width, winH/workingImg.height, 1);
      const displayW=Math.max(320, Math.round(workingImg.width*fitScale));
      const displayH=Math.max(240, Math.round(workingImg.height*fitScale));
      const dpr=window.devicePixelRatio||1;
      canvas.style.width=displayW+'px';
      canvas.style.height=displayH+'px';
      canvas.width=Math.round(displayW*dpr);
      canvas.height=Math.round(displayH*dpr);
      ctx=canvas.getContext('2d');
      ctx.setTransform(dpr,0,0,dpr,0,0);
      const scale=Math.min(displayW/workingImg.width, displayH/workingImg.height);
      const dw=Math.round(workingImg.width*scale);
      const dh=Math.round(workingImg.height*scale);
      const dx=Math.round((displayW - dw)/2);
      const dy=Math.round((displayH - dh)/2);
      imgDraw={dx,dy,dw,dh,scale};
    }

    function applyRotation(delta, skipAuto=false){
      rotation = (rotation + delta + 360) % 360;
      const w = baseImg.naturalWidth;
      const h = baseImg.naturalHeight;
      workingCanvas = document.createElement('canvas');
      const ctx2 = workingCanvas.getContext('2d');
      if (rotation === 0 || rotation === 180){
        workingCanvas.width = w;
        workingCanvas.height = h;
      } else {
        workingCanvas.width = h;
        workingCanvas.height = w;
      }
      ctx2.save();
      switch(rotation){
        case 0:
          ctx2.drawImage(baseImg,0,0);
          break;
        case 90:
          ctx2.translate(workingCanvas.width,0);
          ctx2.rotate(Math.PI/2);
          ctx2.drawImage(baseImg,0,0);
          break;
        case 180:
          ctx2.translate(workingCanvas.width,workingCanvas.height);
          ctx2.rotate(Math.PI);
          ctx2.drawImage(baseImg,0,0);
          break;
        case 270:
          ctx2.translate(0,workingCanvas.height);
          ctx2.rotate(-Math.PI/2);
          ctx2.drawImage(baseImg,0,0);
          break;
      }
      ctx2.restore();
      workingImg.onload = ()=>{
        layoutWorkingImage();
        ensureCornerEls(); ensureEdgeEls();
        if (pendingInitialQuad){
          setHandlesByQuad(pendingInitialQuad);
          statusEl.textContent='已載入上次裁切';
          pendingInitialQuad=null;
        } else {
          setDefaultHandles();
          if (!skipAuto) runAutoDetect(); else statusEl.textContent='';
        }
        wrapper.addEventListener('pointerdown', pointerDown, {passive:false});
      };
      workingImg.src = workingCanvas.toDataURL('image/jpeg', 0.92);
    }

    // 拖曳
    let dragType=null;
    let dragCornerIdx=-1;
    let dragEdgeIdx=-1;
    let lastTap=0;

    function pointerDown(e){
      const target=e.target;
      const rect=canvas.getBoundingClientRect();
      const cx=e.clientX-rect.left, cy=e.clientY-rect.top;

      if (target.dataset && target.dataset.type==='corner'){
        dragType='corner'; dragCornerIdx=parseInt(target.dataset.idx);
      } else if (target.dataset && target.dataset.type==='edge'){
        dragType='edge'; dragEdgeIdx=parseInt(target.dataset.idx);
      } else {
        let best=-1, bestD=Infinity;
        for (let i=0;i<4;i++){
          const px=imgDraw.dx + handles[i].u*imgDraw.dw;
          const py=imgDraw.dy + handles[i].v*imgDraw.dh;
          const d=Math.hypot(px-cx, py-cy);
          if (d<bestD){ bestD=d; best=i; }
        }
        if (bestD <= 36){
          dragType='corner'; dragCornerIdx=best;
        } else {
          const now=Date.now();
          if (now-lastTap<300){
            setDefaultHandles();
            statusEl.textContent='已重設';
          }
          lastTap=now;
          dragType=null;
        }
      }
      if (dragType){
        try { wrapper.setPointerCapture(e.pointerId); } catch(_){}
        window.addEventListener('pointermove', pointerMove, {passive:false});
        window.addEventListener('pointerup', pointerUp, {passive:false});
        e.preventDefault();
      }
    }
    function pointerMove(e){
      if (!dragType) return;
      const rect=canvas.getBoundingClientRect();
      const x=e.clientX-rect.left;
      const y=e.clientY-rect.top;
      if (dragType==='corner' && dragCornerIdx>-1){
        const u=(x - imgDraw.dx)/imgDraw.dw;
        const v=(y - imgDraw.dy)/imgDraw.dh;
        handles[dragCornerIdx].u=Math.max(0,Math.min(1,u));
        handles[dragCornerIdx].v=Math.max(0,Math.min(1,v));
      } else if (dragType==='edge' && dragEdgeIdx>-1){
        const {a,b}=EDGE_MAP[dragEdgeIdx];
        const ax=imgDraw.dx + handles[a].u*imgDraw.dw;
        const ay=imgDraw.dy + handles[a].v*imgDraw.dh;
        const bx=imgDraw.dx + handles[b].u*imgDraw.dw;
        const by=imgDraw.dy + handles[b].v*imgDraw.dh;
        const ex=bx-ax, ey=by-ay;
        const len=Math.hypot(ex,ey)||1;
        let nx=-ey/len, ny=ex/len;
        const mx=(ax+bx)/2, my=(ay+by)/2;
        const dxMove=x-mx, dyMove=y-my;
        const distAlong = dxMove*nx + dyMove*ny;
        const shiftX=nx*distAlong, shiftY=ny*distAlong;
        const du=shiftX/imgDraw.dw, dv=shiftY/imgDraw.dh;
        function apply(i){
          handles[i].u = Math.max(0,Math.min(1, handles[i].u + du));
          handles[i].v = Math.max(0,Math.min(1, handles[i].v + dv));
        }
        apply(a); apply(b);
      }
      positionCornerEls(); updateEdgeHandlePositions(); redraw();
      e.preventDefault();
    }
    function pointerUp(e){
      dragType=null; dragCornerIdx=-1; dragEdgeIdx=-1;
      window.removeEventListener('pointermove', pointerMove);
      window.removeEventListener('pointerup', pointerUp);
      try { wrapper.releasePointerCapture(e.pointerId); } catch(_){}
    }

    document.getElementById('cropResetBtn').onclick=()=>{
      setDefaultHandles(); statusEl.textContent='已重設';
    };
    document.getElementById('autoDetectBtn').onclick=()=>{ autoDone=false; runAutoDetect(); };

    rotateLeftBtn.onclick=()=>{ applyRotation(-90); };
    rotateRightBtn.onclick=()=>{ applyRotation(90); };

    document.getElementById('cropCancelBtn').onclick=()=>{
      cleanup(); reject('cancel');
    };

    function cleanup(){
      modal.style.display='none';
      [...cornerEls, ...edgeEls].forEach(el=>{ if (el && el.parentNode) el.parentNode.removeChild(el); });
      cornerEls=[]; edgeEls=[];
      wrapper.removeEventListener('pointerdown', pointerDown);
    }

    baseImg.onload=()=>{
      workingCanvas=document.createElement('canvas');
      workingCanvas.width=baseImg.naturalWidth;
      workingCanvas.height=baseImg.naturalHeight;
      workingCanvas.getContext('2d').drawImage(baseImg,0,0);
      workingImg.onload=()=>{
        layoutWorkingImage();
        ensureCornerEls(); ensureEdgeEls();
        if (initialQuad){
          setHandlesByQuad(initialQuad);
          statusEl.textContent='已載入上次裁切';
        } else {
          setDefaultHandles();
          runAutoDetect();
        }
        wrapper.addEventListener('pointerdown', pointerDown, {passive:false});
        if (typeof initialRotation==='number' && [0,90,180,270].includes(initialRotation) && initialRotation!==0){
          // 延後設 rotation: 先記錄 quad 以便旋轉後套用
          if (initialQuad) pendingInitialQuad = initialQuad;
          applyRotation((initialRotation - rotation + 360)%360, true); // skip auto
        }
      };
      workingImg.src = workingCanvas.toDataURL('image/jpeg',0.92);
    };
    baseImg.onerror=()=>{ modal.style.display='none'; reject('img_load_error'); };
    baseImg.src = dataUrl;

    document.getElementById('cropConfirmBtn').onclick=()=>{
      const srcPts = handles.map(h=>({
        x: Math.round(h.u * workingImg.width),
        y: Math.round(h.v * workingImg.height)
      }));
      function dist(a,b){ return Math.hypot(a.x-b.x,a.y-b.y); }
      const wA=dist(srcPts[2],srcPts[3]), wB=dist(srcPts[1],srcPts[0]);
      const hA=dist(srcPts[1],srcPts[2]), hB=dist(srcPts[0],srcPts[3]);
      const dstW=Math.min(Math.round(Math.max(wA,wB)), CONFIG.FULL_MAX_DIM);
      const dstH=Math.min(Math.round(Math.max(hA,hB)), CONFIG.FULL_MAX_DIM);
      const dstPts=[{x:0,y:0},{x:dstW-1,y:0},{x:dstW-1,y:dstH-1},{x:0,y:dstH-1}];
      const H=computeHomography(srcPts,dstPts);
      if(!H){ alert('計算失敗，請調整後重試'); return; }
      const srcCanvas=document.createElement('canvas');
      srcCanvas.width=workingImg.width; srcCanvas.height=workingImg.height;
      srcCanvas.getContext('2d').drawImage(workingImg,0,0);
      const warpCanvas=warpImageWithHomography(srcCanvas,H,dstW,dstH);
      const effect=document.getElementById('effectSelect').value;
      applyEffect(warpCanvas, effect);
      cleanup();
      resolve({ croppedCanvas: warpCanvas, effect, quad: srcPts, rotation });
    };
  });
}

/* ========== 縮圖與處理 ========== */
function createResizedCanvas(img,maxDim){
  const r=img.width/img.height;
  let w=img.width, h=img.height;
  if (w>h){ if (w>maxDim){ w=maxDim; h=Math.round(w/r);} }
  else { if (h>maxDim){ h=maxDim; w=Math.round(h*r);} }
  const c=document.createElement('canvas'); c.width=w; c.height=h;
  const ctx=c.getContext('2d'); ctx.fillStyle='#fff'; ctx.fillRect(0,0,w,h);
  ctx.drawImage(img,0,0,img.width,img.height,0,0,w,h);
  return c;
}
function processCroppedCanvas(croppedCanvas,effect){
  return new Promise(resolve=>{
    const tmp=new Image();
    tmp.onload=()=>{
      const full=createResizedCanvas(tmp, CONFIG.FULL_MAX_DIM);
      applyEffect(full,effect);
      const fullDataUrl=full.toDataURL('image/jpeg',CONFIG.IMAGE_QUALITY);
      const preview=createResizedCanvas(tmp, CONFIG.PREVIEW_MAX_WIDTH);
      const previewDataUrl=preview.toDataURL('image/jpeg',0.75);
      resolve({ fullDataUrl, previewDataUrl, w:full.width, h:full.height });
    };
    tmp.src=croppedCanvas.toDataURL('image/jpeg',0.98);
  });
}

/* ========== 新增：再次裁切功能 editImage(id) ========== */
async function editImage(id){
  const item = images.find(i=>i.id===id);
  if (!item) return;
  try{
    const { croppedCanvas, effect, quad, rotation } = await openCropper(item.origDataUrl, {
      initialEffect: item.effect,
      initialQuad: item.quad,
      initialRotation: item.rotation
    });
    const processed=await processCroppedCanvas(croppedCanvas, effect);
    item.fullDataUrl = processed.fullDataUrl;
    item.previewDataUrl = processed.previewDataUrl;
    item.w = processed.w;
    item.h = processed.h;
    item.effect = effect;
    item.quad = quad;
    item.rotation = rotation;
    item.ts = Date.now();
    updatePreview();
  } catch(e){
    if (e!=='cancel') console.warn(e);
  }
}

/* ========== 上傳流程 ========== */
function handleFiles(fileList){
  if(!fileList || !fileList.length) return;
  document.getElementById('loading').style.display='';
  let idx=0;
  (function next(){
    if (idx>=fileList.length){
      document.getElementById('loading').style.display='none';
      return;
    }
    const f=fileList[idx++];
    if(!f.type.startsWith('image/')) return next();
    (async ()=>{
      try{
        const normalizedDataUrl = await loadImageNormalized(f);
        const { croppedCanvas, effect, quad, rotation } = await openCropper(normalizedDataUrl);
        const processed = await processCroppedCanvas(croppedCanvas, effect);
        images.push({
          id: Date.now().toString(36)+Math.random().toString(36).slice(2,9),
          origDataUrl: normalizedDataUrl, // 保存原始(已正確方向)資料以供再次裁切
          fullDataUrl: processed.fullDataUrl,
          previewDataUrl: processed.previewDataUrl,
          w: processed.w,
          h: processed.h,
            effect,
            quad,
            rotation,
          ts: Date.now()
        });
        updatePreview(); updateStorageInfoEstimate();
      } catch(err){
        if (err!=='cancel') console.warn(err);
      } finally {
        next();
      }
    })();
  })();
}
document.getElementById('cameraInput').addEventListener('change', e=>{ handleFiles(e.target.files); e.target.value=''; });
document.getElementById('fileInput').addEventListener('change', e=>{ handleFiles(e.target.files); e.target.value=''; });

function updatePreview(){
  const container=document.getElementById('preview');
  container.innerHTML='';
  images.forEach((o,idx)=>{
    const div=document.createElement('div'); div.className='thumb'; div.dataset.id=o.id;
    const order=document.createElement('div'); order.className='order-label'; order.textContent=idx+1; div.appendChild(order);
    const im=document.createElement('img'); im.src=o.previewDataUrl; im.alt='第 '+(idx+1)+' 張'; div.appendChild(im);
    const del=document.createElement('button'); del.className='remove-btn'; del.textContent='X';
    del.onclick=e=>{
      e.stopPropagation();
      images=images.filter(x=>x.id!==o.id);
      updatePreview(); updateStorageInfoEstimate();
    };
    div.appendChild(del);
    const bar=document.createElement('div'); bar.className='move-bar';
    const up=document.createElement('button'); up.className='move-btn'; up.textContent='↑';
    up.onclick=e=>{
      e.stopPropagation();
      const i=images.findIndex(x=>x.id===o.id);
      if (i>0){ [images[i-1],images[i]]=[images[i],images[i-1]]; updatePreview(); updateStorageInfoEstimate(); }
    };
    const down=document.createElement('button'); down.className='move-btn'; down.textContent='↓';
    down.onclick=e=>{
      e.stopPropagation();
      const i=images.findIndex(x=>x.id===o.id);
      if (i>=0 && i<images.length-1){ [images[i+1],images[i]]=[images[i],images[i+1]]; updatePreview(); updateStorageInfoEstimate(); }
    };
    bar.appendChild(up); bar.appendChild(down); div.appendChild(bar);

    // 點擊縮圖（非按鈕） -> 再次裁切
    div.addEventListener('click', (e)=>{
      if (e.target.closest('.remove-btn') || e.target.closest('.move-btn')) return;
      editImage(o.id);
    });

    container.appendChild(div);
  });
}
function updateStorageInfoEstimate(){
  const el=document.getElementById('storageInfo');
  if (!el) return;
  el.textContent=`目前圖片數量：${images.length}`;
}

function clearAllImages(){ if (confirm('確定刪除全部圖片？')){ images=[]; updatePreview(); updateStorageInfoEstimate(); } }
function triggerCamera(){ document.getElementById('cameraInput').click(); }
function triggerFile(){ document.getElementById('fileInput').click(); }

function getPdfFilename(){
  const d=new Date(), p=n=>String(n).padStart(2,'0');
  return d.getFullYear()+p(d.getMonth()+1)+p(d.getDate())+'_'+p(d.getHours())+p(d.getMinutes())+p(d.getSeconds())+'_轉檔.pdf';
}
function generatePDF(){
  if (!images.length){ alert('請先加入圖片'); return; }
  const firstLandscape = images[0].w > images[0].h;
  const pdf = new jsPDF({unit:'pt', format:'a4', orientation:firstLandscape?'landscape':'portrait'});
  images.forEach((o, idx)=>{
    if (idx>0){
      const isL = o.w > o.h;
      pdf.addPage('a4', isL ? 'landscape':'portrait');
    }
    const pw=pdf.internal.pageSize.getWidth(), ph=pdf.internal.pageSize.getHeight();
    const ratio=Math.min(pw/o.w, ph/o.h);
    const w=o.w*ratio, h=o.h*ratio;
    pdf.addImage(o.fullDataUrl,'JPEG',(pw-w)/2,(ph-h)/2,w,h);
  });
  pdf.save(getPdfFilename());
}

window.addEventListener('DOMContentLoaded', ()=>{
  detectLineInApp();
  updatePreview(); updateStorageInfoEstimate();
});
</script>
</body>
</html>
