<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>文件拍照轉 PDF（四點手動校正 - 含排序與刪除）</title>
<style>
  body { font-family: Arial, "Noto Sans TC", sans-serif; margin:1.2em; background:#fff; }
  h2 { margin-top:0; }
  .actions { display:flex; flex-wrap:wrap; gap:.5em; align-items:center; margin-bottom:.6em; }
  .actions input[type=file]{ display:none; }
  .actions button {
    background:#f5f5f5; border:none; padding:.5em .9em; font-size:.92em;
    border-radius:8px; cursor:pointer;
  }
  .actions button:hover { background:#eaeaea; }
  button.danger { background:#ffecec; color:#b80000; }
  #loading { display:none; font-size:.85em; color:#004; font-weight:bold; margin-left:.6em; }

  #storageInfo { font-size:.88em; color:#666; margin:.4em 0; }

  #preview { display:flex; flex-wrap:wrap; gap:10px; margin-top:.6em; }

  /* thumb */
  .thumb {
    position:relative; width:140px; border:2px solid transparent; border-radius:8px;
    background:#fafafa; padding:8px 8px 34px; box-sizing:border-box;
    user-select:none; -webkit-user-select:none;
    transition:border-color .15s, box-shadow .15s;
  }
  .thumb img {
    width:100%; height:auto; display:block; border:1px solid #ddd;
    border-radius:6px; background:#fff; object-fit:contain;
  }
  .order-label {
    position:absolute; top:8px; left:8px;
    background:#1976d2; color:#fff; font-size:12px;
    padding:4px 7px; border-radius:6px; font-weight:bold; opacity:.95;
  }
  .remove-btn {
    position:absolute; top:8px; right:8px; background:rgba(255,0,0,.9);
    color:#fff; border:none; border-radius:6px; font-size:12px;
    padding:4px 7px; cursor:pointer;
  }
  .move-bar {
    position:absolute; bottom:8px; left:8px; right:8px;
    display:flex; justify-content:center; gap:8px;
  }
  .move-btn {
    background:#fff; border:1px solid #ccc; font-size:13px; padding:6px 8px;
    border-radius:6px; cursor:pointer;
  }
  .move-btn:hover { background:#f6f6f6; }

  /* modal */
  #cropperModal {
    position:fixed; inset:0; background:rgba(0,0,0,0.72);
    display:none; align-items:center; justify-content:center; z-index:9999;
  }
  #cropperModal .modal-content {
    background:#fff; width:95vw; max-width:1100px; border-radius:12px;
    max-height:86vh; overflow:auto; padding:14px;
    box-sizing:border-box;
    display:flex; flex-direction:column; align-items:center;
  }
  #cropperTip { font-size:.92em; color:#333; margin-bottom:8px; text-align:center; }

  /* wrapper & canvas */
  .canvas-wrapper { position: relative; display:inline-block; background:#fafafa; border-radius:8px; }
  canvas#cropperCanvas {
    display:block;
    border-radius:6px;
    background:#fff;
    touch-action: none; /* prevent scroll gestures interfering */
    -webkit-user-select:none; user-select:none;
  }

  /* DOM handles */
  .handle {
    position: absolute;
    width: 28px; height: 28px;
    margin-left: -14px; margin-top: -14px; /* center on point */
    background: #1976d2; border-radius:50%;
    border: 3px solid #fff; box-shadow: 0 2px 6px rgba(0,0,0,0.35);
    z-index: 60; touch-action:none; cursor:grab;
  }
  .handle.mid { background:#03a9f4; } /* 可視化中間點顏色不同（可選） */
  .handle:active { cursor:grabbing; }

  .controls { margin-top:10px; display:flex; gap:.6em; align-items:center; flex-wrap:wrap; }
  select { padding:.35em .6em; border-radius:6px; border:1px solid #ccc; background:#fff; }
  .guide { font-size:.86em; color:#666; margin-top:8px; text-align:center; }

  #cropperBtns { margin-top:12px; display:flex; gap:.6em; }
  #cropperBtns button { padding:.5em .8em; border-radius:8px; border:none; background:#f5f5f5; cursor:pointer; }
  #cropperBtns button:hover { background:#eaeaea; }

  @media (max-width:560px) {
    .thumb { width:30vw; max-width:150px; padding-bottom:34px; }
    .handle { width:34px; height:34px; margin-left:-17px; margin-top:-17px; }
    #cropperModal .modal-content { padding:10px; }
  }
</style>
<script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
</head>
<body>
<h2>📄 文件拍照轉 PDF（四點手動校正 - 含排序與刪除）</h2>

<div class="actions">
  <input type="file" accept="image/*" capture="environment" id="cameraInput">
  <input type="file" accept="image/*" multiple id="fileInput">
  <button onclick="triggerCamera()">📷 拍照</button>
  <button onclick="triggerFile()">🖼️ 選照片</button>
  <button onclick="generatePDF()">🧾 產生 PDF</button>
  <button class="danger" onclick="clearAllImages()">🗑️ 清除全部</button>
  <span id="loading">處理中...</span>
</div>

<!-- 顯示目前圖片數量 -->
<div id="storageInfo">目前圖片數量：0</div>

<div id="preview"></div>

<!-- 裁切 Modal -->
<div id="cropperModal" role="dialog" aria-modal="true">
  <div class="modal-content">
    <div id="cropperTip">拖曳四個藍色圓點來對準紙張四角，或拖曳邊中間的藍點可將該邊「平行」放大/縮小。雙擊畫面可重設。</div>

    <div id="canvasContainer" class="canvas-wrapper" style="touch-action:none;">
      <canvas id="cropperCanvas" width="800" height="600"></canvas>
      <!-- handles inserted here as DOM nodes -->
    </div>

    <div class="controls">
      <label>效果：
        <select id="effectSelect">
          <option value="original">原色</option>
          <option value="gray">灰階</option>
          <option value="bw">黑白（高對比）</option>
        </select>
      </label>
    </div>

    <div class="guide">如果看不到下方點，請將畫面放大或點選點附近（會自動選取最近的點）。</div>

    <div id="cropperBtns">
      <button id="cropResetBtn">重設</button>
      <button id="cropConfirmBtn">確定裁切</button>
      <button id="cropCancelBtn">取消</button>
    </div>
  </div>
</div>

<script>
/* Config */
const CONFIG = {
  FULL_MAX_DIM: 2000,
  PREVIEW_MAX_WIDTH: 420,
  IMAGE_QUALITY: 0.9
};
let images = []; // 存放已處理的影像物件
const { jsPDF } = window.jspdf || {};

/* ---------- Homography & Warp (bilinear) helpers ---------- */
function solveLinearSystem(A, b) {
  const n = A.length;
  const M = new Array(n).fill(0).map((_,i)=>A[i].slice().concat(b[i]));
  for (let k=0;k<n;k++){
    let i_max=k;
    for (let i=k+1;i<n;i++) if (Math.abs(M[i][k]) > Math.abs(M[i_max][k])) i_max=i;
    if (Math.abs(M[i_max][k]) < 1e-12) return null;
    [M[k], M[i_max]] = [M[i_max], M[k]];
    const piv = M[k][k];
    for (let j=k;j<=n;j++) M[k][j] /= piv;
    for (let i=0;i<n;i++) if (i!==k) {
      const f = M[i][k];
      for (let j=k;j<=n;j++) M[i][j] -= f * M[k][j];
    }
  }
  return M.map(row=>row[n]);
}
function computeHomography(srcPts, dstPts) {
  const A=[], b=[];
  for (let i=0;i<4;i++){
    const {x,y}=srcPts[i], {x:u,y:v}=dstPts[i];
    A.push([x,y,1,0,0,0,-u*x,-u*y]); b.push(u);
    A.push([0,0,0,x,y,1,-v*x,-v*y]); b.push(v);
  }
  const h = solveLinearSystem(A,b);
  if (!h) return null;
  return [[h[0],h[1],h[2]],[h[3],h[4],h[5]],[h[6],h[7],1]];
}
function invert3x3(m){
  const a=m[0][0],b=m[0][1],c=m[0][2],
        d=m[1][0],e=m[1][1],f=m[1][2],
        g=m[2][0],h=m[2][1],i=m[2][2];
  const A=e*i-f*h, B=c*h-b*i, C=b*f-c*e;
  const D=f*g-d*i, E=a*i-c*g, F=c*d-a*f;
  const G=d*h-e*g, H=b*g-a*h, I=a*e-b*d;
  const det = a*A + b*D + c*G;
  if (Math.abs(det) < 1e-12) return null;
  const inv = 1/det;
  return [[A*inv,B*inv,C*inv],[D*inv,E*inv,F*inv],[G*inv,H*inv,I*inv]];
}
function warpImageWithHomography(srcCanvas, H, dstW, dstH){
  const dst = document.createElement('canvas');
  dst.width = dstW; dst.height = dstH;
  const dstCtx = dst.getContext('2d');
  const srcCtx = srcCanvas.getContext('2d');
  const srcW = srcCanvas.width, srcH = srcCanvas.height;
  const srcImgData = srcCtx.getImageData(0,0,srcW,srcH);
  const srcData = srcImgData.data;
  const dstImgData = dstCtx.createImageData(dstW, dstH);
  const dstData = dstImgData.data;
  const Hinv = invert3x3(H);
  if (!Hinv){ dstCtx.drawImage(srcCanvas,0,0,dstW,dstH); return dst; }
  for (let j=0;j<dstH;j++){
    for (let i=0;i<dstW;i++){
      const denom = Hinv[2][0]*i + Hinv[2][1]*j + Hinv[2][2];
      if (denom === 0) continue;
      const sx = (Hinv[0][0]*i + Hinv[0][1]*j + Hinv[0][2]) / denom;
      const sy = (Hinv[1][0]*i + Hinv[1][1]*j + Hinv[1][2]) / denom;
      // bilinear sampling
      let sample;
      if (sx<0||sy<0||sx>=srcW||sy>=srcH) {
        const xi = Math.min(Math.max(Math.round(sx),0), srcW-1);
        const yi = Math.min(Math.max(Math.round(sy),0), srcH-1);
        const idx = (yi*srcW + xi)*4;
        sample = [srcData[idx], srcData[idx+1], srcData[idx+2], srcData[idx+3]];
      } else {
        const x0 = Math.floor(sx), y0 = Math.floor(sy), x1 = Math.min(x0+1, srcW-1), y1 = Math.min(y0+1, srcH-1);
        const dx = sx - x0, dy = sy - y0;
        const idx00 = (y0*srcW + x0)*4, idx10 = (y0*srcW + x1)*4;
        const idx01 = (y1*srcW + x0)*4, idx11 = (y1*srcW + x1)*4;
        sample = [0,0,0,0];
        for (let c=0;c<4;c++){
          const v00 = srcData[idx00+c], v10 = srcData[idx10+c], v01 = srcData[idx01+c], v11 = srcData[idx11+c];
          const v0 = v00*(1-dx) + v10*dx;
          const v1 = v01*(1-dx) + v11*dx;
          sample[c] = Math.round(v0*(1-dy) + v1*dy);
        }
      }
      const dstIdx = (j*dstW + i)*4;
      dstData[dstIdx]   = sample[0];
      dstData[dstIdx+1] = sample[1];
      dstData[dstIdx+2] = sample[2];
      dstData[dstIdx+3] = sample[3];
    }
  }
  dstCtx.putImageData(dstImgData, 0, 0);
  return dst;
}
function applyEffect(canvas, effect){
  if (!canvas || effect === 'original') return;
  const ctx = canvas.getContext('2d');
  const imgd = ctx.getImageData(0,0,canvas.width, canvas.height);
  const d = imgd.data;
  for (let i=0;i<d.length;i+=4){
    const r=d[i], g=d[i+1], b=d[i+2];
    const lum = 0.299*r + 0.587*g + 0.114*b;
    d[i]=d[i+1]=d[i+2]=lum;
  }
  if (effect === 'bw'){
    const hist = new Array(256).fill(0);
    for (let i=0;i<d.length;i+=4) hist[Math.round(d[i])]++;
    let total = canvas.width*canvas.height, sum=0;
    for (let t=0;t<256;t++) sum += t*hist[t];
    let wB=0,sumB=0,varMax=0,th=0;
    for (let t=0;t<256;t++){
      wB += hist[t];
      if (!wB) continue;
      const wF = total - wB;
      if (!wF) break;
      sumB += t*hist[t];
      const mB = sumB/wB;
      const mF = (sum - sumB)/wF;
      const v = wB*wF*(mB-mF)*(mB-mF);
      if (v > varMax){ varMax=v; th=t; }
    }
    for (let i=0;i<d.length;i+=4){
      const v = d[i] > th ? 255 : 0;
      d[i]=d[i+1]=d[i+2]=v;
    }
  }
  ctx.putImageData(imgd, 0, 0);
}

/* ---------- EXIF orientation helpers ---------- */
/* 讀 JPEG ArrayBuffer 找到 Exif orientation (1..8)，找不到則回傳 1 */
function readImageOrientation(arrayBuffer){
  try {
    const view = new DataView(arrayBuffer);
    if (view.getUint16(0) !== 0xFFD8) return 1; // not JPEG
    let offset = 2;
    const len = view.byteLength;
    while (offset < len) {
      if (view.getUint8(offset) !== 0xFF) break;
      const marker = view.getUint8(offset + 1);
      offset += 2;
      if (marker === 0xE1) { // APP1 (Exif)
        const app1Len = view.getUint16(offset);
        offset += 2;
        // check "Exif\0\0"
        if (view.getUint32(offset) !== 0x45786966) return 1; // "Exif"
        offset += 6;
        const little = view.getUint16(offset) === 0x4949;
        const getUint16 = (o) => little ? view.getUint16(o, true) : view.getUint16(o, false);
        const getUint32 = (o) => little ? view.getUint32(o, true) : view.getUint32(o, false);
        const tiffOffset = offset;
        const firstIFDOffset = getUint32(tiffOffset + 4);
        let dirOffset = tiffOffset + firstIFDOffset;
        const numEntries = getUint16(dirOffset);
        dirOffset += 2;
        for (let i = 0; i < numEntries; i++) {
          const entryOffset = dirOffset + i*12;
          const tag = getUint16(entryOffset);
          if (tag === 0x0112) {
            const value = getUint16(entryOffset + 8);
            return value;
          }
        }
        break;
      } else {
        const size = view.getUint16(offset);
        offset += size;
      }
    }
  } catch (e) {
    console.warn('readImageOrientation error', e);
  }
  return 1;
}

/* 根據 EXIF orientation 將 dataURL 的影像畫成正確方向，回傳新的 dataURL */
function normalizeDataUrlByOrientation(dataUrl, orientation){
  return new Promise((resolve, reject) => {
    if (!orientation || orientation === 1) return resolve(dataUrl);
    const img = new Image();
    img.onload = () => {
      let w = img.width, h = img.height;
      let canvas = document.createElement('canvas');
      let ctx = canvas.getContext('2d');

      // orientation 5/6/7/8 => rotate 90/270, swap dims
      if (orientation >=5 && orientation <=8) {
        canvas.width = h; canvas.height = w;
      } else {
        canvas.width = w; canvas.height = h;
      }

      // apply transform
      switch(orientation){
        case 2: // horizontal flip
          ctx.translate(w, 0); ctx.scale(-1,1); break;
        case 3: // rotate 180
          ctx.translate(w, h); ctx.rotate(Math.PI); break;
        case 4: // vertical flip
          ctx.translate(0, h); ctx.scale(1,-1); break;
        case 5: // transpose: flip horizontal and rotate 90
          ctx.rotate(0.5*Math.PI); ctx.scale(1,-1); break;
        case 6: // rotate 90
          ctx.rotate(0.5*Math.PI); ctx.translate(0, -h); break;
        case 7: // transverse: flip vertical and rotate 90
          ctx.rotate(0.5*Math.PI); ctx.translate(w, -h); ctx.scale(-1,1); break;
        case 8: // rotate 270
          ctx.rotate(-0.5*Math.PI); ctx.translate(-w, 0); break;
        default:
          break;
      }

      ctx.drawImage(img, 0, 0);
      try {
        const normalized = canvas.toDataURL('image/jpeg', 0.98);
        resolve(normalized);
      } catch (e) {
        console.warn('normalizeDataUrlByOrientation failed', e);
        resolve(dataUrl);
      }
    };
    img.onerror = (e) => { resolve(dataUrl); };
    img.src = dataUrl;
  });
}

/* ---------- openCropper (DOM handles) with mid-edge handles ---------- */
function openCropper(dataUrl){
  return new Promise((resolve, reject) => {
    const modal = document.getElementById('cropperModal');
    const canvas = document.getElementById('cropperCanvas');
    const wrapper = document.getElementById('canvasContainer');
    let ctx = canvas.getContext('2d');

    modal.style.display = 'flex';

    const img = new Image();
    let imgDraw = { dx:0, dy:0, dw:0, dh:0, scale:1 }; // CSS px
    let handles = [];       // 4 corner handles: {u,v} normalized in image-pixel coords
    let handleEls = [];     // DOM nodes for 8 handles (4 corners + 4 mid-edge)
    let dragState = null;   // store drag info when dragging

    function ensureHandles(){
      wrapper.style.position = 'relative';
      // create 8 handles: 0-3 corners, 4-7 mid-edge between corner i and i+1
      for (let i=0;i<8;i++){
        if (!handleEls[i]){
          const el = document.createElement('div');
          el.className = 'handle' + (i>=4 ? ' mid' : '');
          el.dataset.idx = i;
          // prevent default pointerdown to avoid scrolling
          el.addEventListener('pointerdown', (ev) => { ev.preventDefault(); });
          wrapper.appendChild(el);
          handleEls[i] = el;
        }
      }
    }
    function computeMid(u1,v1,u2,v2){
      return { u: (u1+u2)/2, v: (v1+v2)/2 };
    }
    function positionHandleEls(){
      // corners
      for (let i=0;i<4;i++){
        const el = handleEls[i];
        const px = imgDraw.dx + handles[i].u * imgDraw.dw;
        const py = imgDraw.dy + handles[i].v * imgDraw.dh;
        el.style.left = px + 'px';
        el.style.top  = py + 'px';
      }
      // mids
      for (let i=0;i<4;i++){
        const a = i;
        const b = (i+1)%4;
        const mid = computeMid(handles[a].u, handles[a].v, handles[b].u, handles[b].v);
        const el = handleEls[4+i];
        const px = imgDraw.dx + mid.u * imgDraw.dw;
        const py = imgDraw.dy + mid.v * imgDraw.dh;
        el.style.left = px + 'px';
        el.style.top  = py + 'px';
      }
    }
    function drawCanvas(){
      ctx.save();
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.restore();
      ctx.drawImage(img, 0,0, img.width, img.height, imgDraw.dx, imgDraw.dy, imgDraw.dw, imgDraw.dh);
      // draw polygon
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(25,118,210,0.95)';
      ctx.beginPath();
      for (let i=0;i<4;i++){
        const p = { x: imgDraw.dx + handles[i].u * imgDraw.dw, y: imgDraw.dy + handles[i].v * imgDraw.dh };
        if (i===0) ctx.moveTo(p.x, p.y);
        else ctx.lineTo(p.x, p.y);
      }
      ctx.closePath();
      ctx.stroke();
    }
    function resetHandles(){
      const inset = 0.06;
      handles = [
        { u: inset, v: inset },
        { u: 1 - inset, v: inset },
        { u: 1 - inset, v: 1 - inset },
        { u: inset, v: 1 - inset }
      ];
      if (handleEls.length) positionHandleEls();
      drawCanvas();
    }

    // wrapper-level pointer handling with support for corner and mid-edge dragging
    function wrapperPointerDown(e){
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      let bestIdx = -1, bestD = Infinity;
      // compute distances to all 8 handles (we present mid handles as positions too)
      for (let i=0;i<8;i++){
        let hx, hy;
        if (i < 4){
          hx = imgDraw.dx + handles[i].u * imgDraw.dw;
          hy = imgDraw.dy + handles[i].v * imgDraw.dh;
        } else {
          const a = i - 4;
          const b = (a + 1) % 4;
          const mid = computeMid(handles[a].u, handles[a].v, handles[b].u, handles[b].v);
          hx = imgDraw.dx + mid.u * imgDraw.dw;
          hy = imgDraw.dy + mid.v * imgDraw.dh;
        }
        const d = Math.hypot(hx - x, hy - y);
        if (d < bestD) { bestD = d; bestIdx = i; }
      }
      const HIT_RADIUS = Math.max(28, Math.min(48, Math.round(Math.min(imgDraw.dw, imgDraw.dh) * 0.06)));
      if (bestD <= HIT_RADIUS){
        // start dragging
        try { wrapper.setPointerCapture && wrapper.setPointerCapture(e.pointerId); } catch(_) {}
        dragState = {
          idx: bestIdx,
          pointerStart: { x: e.clientX, y: e.clientY },
          // copy corner handle pixel positions for robust drag math
          startCornersPx: handles.map(h => ({
            x: imgDraw.dx + h.u * imgDraw.dw,
            y: imgDraw.dy + h.v * imgDraw.dh
          }))
        };
        if (bestIdx >= 4){
          // mid-edge drag: compute normalized edge normal (in CSS pixels)
          const a = bestIdx - 4;
          const b = (a + 1) % 4;
          const ax = dragState.startCornersPx[a].x, ay = dragState.startCornersPx[a].y;
          const bx = dragState.startCornersPx[b].x, by = dragState.startCornersPx[b].y;
          // edge vector from a->b
          const ex = bx - ax, ey = by - ay;
          // normal (perp)
          let nx = -ey, ny = ex;
          const norm = Math.hypot(nx, ny) || 1;
          nx /= norm; ny /= norm;
          dragState.edge = { a, b, nx, ny };
        }
        window.addEventListener('pointermove', wrapperPointerMove, { passive: false });
        window.addEventListener('pointerup', wrapperPointerUp, { passive: false });
        e.preventDefault();
      }
    }
    function wrapperPointerMove(e){
      if (!dragState) return;
      const rect = canvas.getBoundingClientRect();
      const px = e.clientX - rect.left;
      const py = e.clientY - rect.top;
      if (dragState.idx < 4){
        // corner drag: same as before but work in image-relative normalized coords
        const u = (px - imgDraw.dx) / imgDraw.dw;
        const v = (py - imgDraw.dy) / imgDraw.dh;
        handles[dragState.idx].u = Math.max(0, Math.min(1, u));
        handles[dragState.idx].v = Math.max(0, Math.min(1, v));
        positionHandleEls();
        drawCanvas();
      } else {
        // mid-edge drag: move both adjacent corners along the edge normal by the projected delta
        const { a, b, nx, ny } = dragState.edge;
        // compute pointer delta from start in CSS coords
        const dx = e.clientX - dragState.pointerStart.x;
        const dy = e.clientY - dragState.pointerStart.y;
        // project delta onto normal
        const delta = dx * nx + dy * ny;
        // new positions for corners in px:
        const newAx = dragState.startCornersPx[a].x + nx * delta;
        const newAy = dragState.startCornersPx[a].y + ny * delta;
        const newBx = dragState.startCornersPx[b].x + nx * delta;
        const newBy = dragState.startCornersPx[b].y + ny * delta;
        // convert back to normalized u/v in image coords
        const newAu = (newAx - imgDraw.dx) / imgDraw.dw;
        const newAv = (newAy - imgDraw.dy) / imgDraw.dh;
        const newBu = (newBx - imgDraw.dx) / imgDraw.dw;
        const newBv = (newBy - imgDraw.dy) / imgDraw.dh;
        // clamp to [0,1]
        handles[a].u = Math.max(0, Math.min(1, newAu));
        handles[a].v = Math.max(0, Math.min(1, newAv));
        handles[b].u = Math.max(0, Math.min(1, newBu));
        handles[b].v = Math.max(0, Math.min(1, newBv));
        positionHandleEls();
        drawCanvas();
      }
      e.preventDefault();
    }
    function wrapperPointerUp(e){
      try { wrapper.releasePointerCapture && wrapper.releasePointerCapture(e.pointerId); } catch(_) {}
      dragState = null;
      window.removeEventListener('pointermove', wrapperPointerMove);
      window.removeEventListener('pointerup', wrapperPointerUp);
    }

    let lastTap = 0;
    function onCanvasPointerDown(ev){
      const now = Date.now();
      if (now - lastTap < 300) resetHandles();
      lastTap = now;
    }

    document.getElementById('cropResetBtn').onclick = () => { resetHandles(); };
    document.getElementById('cropCancelBtn').onclick = () => { cleanupReject('cancel'); };

    function cleanupReject(reason){
      modal.style.display = 'none';
      handleEls.forEach(el => { try { if (el.parentNode) el.parentNode.removeChild(el); } catch(_){} });
      handleEls = [];
      wrapper.removeEventListener('pointerdown', wrapperPointerDown);
      canvas.removeEventListener('pointerdown', onCanvasPointerDown);
      resolve(Promise.reject(reason));
    }

    img.onload = () => {
      const winW = Math.min(window.innerWidth * 0.92, 1200);
      const winH = Math.min(window.innerHeight * 0.7, 1100);
      const fitScale = Math.min(winW / img.width, winH / img.height, 1);
      const displayW = Math.max(320, Math.round(img.width * fitScale));
      const displayH = Math.max(240, Math.round(img.height * fitScale));
      const dpr = window.devicePixelRatio || 1;
      canvas.style.width  = displayW + 'px';
      canvas.style.height = displayH + 'px';
      canvas.width  = Math.round(displayW * dpr);
      canvas.height = Math.round(displayH * dpr);
      ctx = canvas.getContext('2d');
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      const scale = Math.min(displayW / img.width, displayH / img.height);
      const dw = Math.round(img.width * scale);
      const dh = Math.round(img.height * scale);
      const dx = Math.round((displayW - dw) / 2);
      const dy = Math.round((displayH - dh) / 2);
      imgDraw = { dx, dy, dw, dh, scale };
      wrapper.style.width = canvas.style.width;
      wrapper.style.height = canvas.style.height;
      wrapper.style.display = 'inline-block';
      wrapper.style.position = 'relative';
      wrapper.style.touchAction = 'none';
      ensureHandles();
      resetHandles();
      positionHandleEls();
      drawCanvas();
      wrapper.addEventListener('pointerdown', wrapperPointerDown, { passive: false });
      canvas.addEventListener('pointerdown', onCanvasPointerDown, { passive: false });
    };
    img.onerror = () => { modal.style.display = 'none'; reject('img_load_error'); };
    img.src = dataUrl;

    document.getElementById('cropConfirmBtn').onclick = async () => {
      const srcPts = handles.map(h => ({ x: Math.round(h.u * img.width), y: Math.round(h.v * img.height) }));
      function dist(a,b){ return Math.hypot(a.x-b.x,a.y-b.y); }
      const wA = dist(srcPts[2], srcPts[3]), wB = dist(srcPts[1], srcPts[0]);
      const hA = dist(srcPts[1], srcPts[2]), hB = dist(srcPts[0], srcPts[3]);
      const dstW = Math.min(Math.round(Math.max(wA,wB)), CONFIG.FULL_MAX_DIM);
      const dstH = Math.min(Math.round(Math.max(hA,hB)), CONFIG.FULL_MAX_DIM);
      const dstPts = [{x:0,y:0},{x:dstW-1,y:0},{x:dstW-1,y:dstH-1},{x:0,y:dstH-1}];
      const H = computeHomography(srcPts, dstPts);
      if (!H) { alert('計算失敗，請調整四點後重試'); return; }
      const srcCanvas = document.createElement('canvas');
      srcCanvas.width = img.width; srcCanvas.height = img.height;
      const sctx = srcCanvas.getContext('2d');
      sctx.drawImage(img, 0,0);
      const warpCanvas = warpImageWithHomography(srcCanvas, H, dstW, dstH);
      const effect = document.getElementById('effectSelect').value;
      applyEffect(warpCanvas, effect);
      handleEls.forEach(el => { try { if (el.parentNode) el.parentNode.removeChild(el); } catch(_){} });
      handleEls = [];
      wrapper.removeEventListener('pointerdown', wrapperPointerDown);
      canvas.removeEventListener('pointerdown', onCanvasPointerDown);
      modal.style.display = 'none';
      resolve({ croppedCanvas: warpCanvas, effect });
    };
  });
}

/* ---------- processing pipeline ---------- */
function createResizedCanvas(img, maxDim){
  const r = img.width / img.height;
  let w = img.width, h = img.height;
  if (w > h) { if (w > maxDim){ w = maxDim; h = Math.round(w / r); } }
  else { if (h > maxDim){ h = maxDim; w = Math.round(h * r); } }
  const c = document.createElement('canvas'); c.width = w; c.height = h;
  const ctx = c.getContext('2d'); ctx.fillStyle = '#fff'; ctx.fillRect(0,0,w,h);
  ctx.drawImage(img, 0,0, img.width, img.height, 0,0, w,h);
  return c;
}
function processCroppedCanvas(croppedCanvas, effect){
  return new Promise(resolve=>{
    const tmp = new Image();
    tmp.onload = () => {
      const full = createResizedCanvas(tmp, CONFIG.FULL_MAX_DIM);
      applyEffect(full, effect);
      const fullDataUrl = full.toDataURL('image/jpeg', CONFIG.IMAGE_QUALITY);
      const preview = createResizedCanvas(tmp, CONFIG.PREVIEW_MAX_WIDTH);
      const previewDataUrl = preview.toDataURL('image/jpeg', 0.75);
      resolve({ fullDataUrl, previewDataUrl, w: full.width, h: full.height });
    };
    tmp.src = croppedCanvas.toDataURL('image/jpeg', 0.98);
  });
}

/* ---------- file handling & UI glue ---------- */
function readFileAsArrayBuffer(file){
  return new Promise((resolve, reject) => {
    const fr = new FileReader();
    fr.onload = () => resolve(fr.result);
    fr.onerror = reject;
    fr.readAsArrayBuffer(file);
  });
}
function readFileAsDataURL(file){
  return new Promise((resolve, reject) => {
    const fr = new FileReader();
    fr.onload = () => resolve(fr.result);
    fr.onerror = reject;
    fr.readAsDataURL(file);
  });
}

function handleFiles(fileList){
  if (!fileList || !fileList.length) return;
  document.getElementById('loading').style.display = '';
  let idx = 0;
  (function next(){
    if (idx >= fileList.length) { document.getElementById('loading').style.display = 'none'; return; }
    const f = fileList[idx++];
    if (!f.type.startsWith('image/')) return next();
    (async () => {
      try {
        // 讀取 ArrayBuffer 以解析 EXIF orientation，同時讀 DataURL
        const [arrayBuffer, dataUrl] = await Promise.all([readFileAsArrayBuffer(f), readFileAsDataURL(f)]);
        const orientation = readImageOrientation(arrayBuffer) || 1;
        let normalizedDataUrl = dataUrl;
        if (orientation && orientation !== 1){
          normalizedDataUrl = await normalizeDataUrlByOrientation(dataUrl, orientation);
        }
        const { croppedCanvas, effect } = await openCropper(normalizedDataUrl);
        const processed = await processCroppedCanvas(croppedCanvas, effect);
        images.push({
          id: Date.now().toString(36) + Math.random().toString(36).slice(2,9),
          fullDataUrl: processed.fullDataUrl,
          previewDataUrl: processed.previewDataUrl,
          w: processed.w, h: processed.h, ts: Date.now()
        });
        updatePreview();
        updateStorageInfoEstimate();
      } catch(err){
        if (err !== 'cancel') console.warn(err);
      } finally {
        next();
      }
    })();
  })();
}
document.getElementById('cameraInput').addEventListener('change', e => { handleFiles(e.target.files); e.target.value=''; });
document.getElementById('fileInput').addEventListener('change', e => { handleFiles(e.target.files); e.target.value=''; });

/* ---------- preview, sorting, delete, storage info ---------- */
function updatePreview(){
  const container = document.getElementById('preview');
  container.innerHTML = '';
  images.forEach((o, idx) => {
    const div = document.createElement('div');
    div.className = 'thumb';
    div.dataset.id = o.id;

    const order = document.createElement('div');
    order.className = 'order-label';
    order.textContent = idx + 1;
    div.appendChild(order);

    const img = document.createElement('img');
    img.src = o.previewDataUrl;
    img.alt = '第 ' + (idx+1) + ' 張';
    div.appendChild(img);

    const del = document.createElement('button');
    del.className = 'remove-btn';
    del.textContent = 'X';
    del.title = '刪除此張';
    del.onclick = (e) => {
      e.stopPropagation();
      images = images.filter(x => x.id !== o.id);
      updatePreview();
      updateStorageInfoEstimate();
    };
    div.appendChild(del);

    const bar = document.createElement('div');
    bar.className = 'move-bar';

    const up = document.createElement('button');
    up.className = 'move-btn';
    up.textContent = '↑';
    up.title = '上移';
    up.onclick = (e) => {
      e.stopPropagation();
      const i = images.findIndex(x => x.id === o.id);
      if (i > 0) {
        const tmp = images[i-1];
        images[i-1] = images[i];
        images[i] = tmp;
        updatePreview();
        updateStorageInfoEstimate();
      }
    };

    const down = document.createElement('button');
    down.className = 'move-btn';
    down.textContent = '↓';
    down.title = '下移';
    down.onclick = (e) => {
      e.stopPropagation();
      const i = images.findIndex(x => x.id === o.id);
      if (i >= 0 && i < images.length - 1) {
        const tmp = images[i+1];
        images[i+1] = images[i];
        images[i] = tmp;
        updatePreview();
        updateStorageInfoEstimate();
      }
    };

    bar.appendChild(up);
    bar.appendChild(down);
    div.appendChild(bar);

    container.appendChild(div);
  });
  updateStorageInfoEstimate();
}

function updateStorageInfoEstimate(){
  const el = document.getElementById('storageInfo');
  if (!el) return;
  el.textContent = `目前圖片數量：${images.length}`;
}

/* ---------- simple UI helpers ---------- */
function clearAllImages(){ if (confirm('確定刪除全部圖片？')) { images = []; updatePreview(); updateStorageInfoEstimate(); } }
function triggerCamera(){ document.getElementById('cameraInput').click(); }
function triggerFile(){ document.getElementById('fileInput').click(); }

function getPdfFilename(){
  const d=new Date(), p=n=>String(n).padStart(2,'0');
  return d.getFullYear()+p(d.getMonth()+1)+p(d.getDate())+'_'+p(d.getHours())+p(d.getMinutes())+p(d.getSeconds())+'_轉檔.pdf';
}
function generatePDF(){
  if (!images.length){ alert('請先加入圖片'); return; }
  const pdf = new jsPDF({unit:'pt', format:'a4', orientation: 'portrait'});
  let first=true;
  images.forEach(o=>{
    const isLandscape = o.w > o.h;
    if (first){ pdf.deletePage(1); pdf.addPage('a4', isLandscape ? 'landscape' : 'portrait'); first=false; }
    else pdf.addPage('a4', isLandscape ? 'landscape' : 'portrait');
    const pdfW = pdf.internal.pageSize.getWidth();
    const pdfH = pdf.internal.pageSize.getHeight();
    const ratio = Math.min(pdfW / o.w, pdfH / o.h);
    const w = o.w * ratio, h = o.h * ratio;
    const x = (pdfW - w) / 2, y = (pdfH - h) / 2;
    pdf.addImage(o.fullDataUrl, 'JPEG', x, y, w, h);
  });
  pdf.save(getPdfFilename());
}

/* init */
window.addEventListener('DOMContentLoaded', ()=>{ updatePreview(); updateStorageInfoEstimate(); });
</script>
</body>
</html>
