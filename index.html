<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>æ–‡ä»¶æ‹ç…§è½‰ PDFï¼ˆè‡ªå‹•è£åˆ‡ï¼‹å¼·åŒ–å°æ¯”ï¼‰</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 2em; }
    .preview { display: flex; flex-wrap: wrap; gap: 10px; margin: 1em 0; }
    .preview-item { position: relative; }
    .preview-item img { width: 120px; border: 1px solid #aaa; border-radius: 4px; }
    .remove-btn {
      position: absolute; top: 2px; right: 2px;
      background: rgba(255,0,0,0.8); color: #fff; border: none; border-radius: 3px;
      cursor: pointer; font-size: 12px; padding: 2px 6px;
    }
    .actions { margin-bottom: 1em; }
    button { font-size: 1em; margin-right: .5em; }
    #loading { display:none; color: #009; font-weight: bold; }
  </style>
  <!-- é‡è¦ï¼šè¼‰å…¥ OpenCV.js -->
  <script async src="https://docs.opencv.org/4.x/opencv.js" type="text/javascript"></script>
</head>
<body>
  <h2>ğŸ“„ æ–‡ä»¶æ‹ç…§è½‰ PDFï¼ˆè‡ªå‹•è£åˆ‡ï¼‹å¼·åŒ–å°æ¯”ï¼‰</h2>
  <div class="actions">
    <input type="file" accept="image/*" capture="environment" id="cameraInput" style="display:none">
    <input type="file" accept="image/*" multiple id="fileInput" style="display:none">
    <button onclick="document.getElementById('cameraInput').click()">ğŸ“· æ‹ç…§</button>
    <button onclick="document.getElementById('fileInput').click()">ğŸ–¼ï¸ é¸ç…§ç‰‡</button>
    <button onclick="generatePDF()">ğŸ§¾ ç”¢ç”Ÿ PDF</button>
    <span id="loading">åœ–ç‰‡è™•ç†ä¸­ï¼Œè«‹ç¨å€™...</span>
  </div>
  <div class="preview" id="preview"></div>

  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
  <script>
    const { jsPDF } = window.jspdf;
    let images = [];
    let cvReady = false;

    // ç­‰å¾… OpenCV è¼‰å…¥
    function onOpenCvReady() {
      cvReady = true;
    }
    window.Module = { onRuntimeInitialized: onOpenCvReady };

    // å½±åƒè™•ç†æ ¸å¿ƒï¼šè‡ªå‹•è£åˆ‡ï¼‹ç°éšï¼‹å°æ¯”å¼·åŒ–
    async function processImageAutoCropAndEnhance(img) {
      return new Promise((resolve) => {
        // å»ºç«‹ canvas å–å¾—åƒç´ 
        const canvas = document.createElement('canvas');
        canvas.width = img.naturalWidth || img.width;
        canvas.height = img.naturalHeight || img.height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

        // å–å¾— imageData
        let src = cv.imread(canvas);
        let dst = new cv.Mat();
        let gray = new cv.Mat();
        let blurred = new cv.Mat();
        let edged = new cv.Mat();

        // ç°éš
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);

        // æ¨¡ç³Šé™å™ª
        cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0, 0, cv.BORDER_DEFAULT);

        // é‚Šç·£åµæ¸¬
        cv.Canny(blurred, edged, 60, 150);

        // è¼ªå»“åµæ¸¬
        let contours = new cv.MatVector();
        let hierarchy = new cv.Mat();
        cv.findContours(edged, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

        // æ‰¾æœ€å¤§å››é‚Šå½¢
        let maxArea = 0, pageContour = null;
        for (let i = 0; i < contours.size(); i++) {
          let cnt = contours.get(i);
          let peri = cv.arcLength(cnt, true);
          let approx = new cv.Mat();
          cv.approxPolyDP(cnt, approx, 0.02 * peri, true);
          if (approx.rows === 4) {
            let area = cv.contourArea(cnt);
            if (area > maxArea) {
              maxArea = area;
              pageContour = approx;
            } else {
              approx.delete();
            }
          } else {
            approx.delete();
          }
          cnt.delete();
        }

        let resultCanvas = document.createElement('canvas');
        let resultCtx = resultCanvas.getContext('2d');

        // è‹¥æ‰¾åˆ°å››é‚Šå½¢ï¼Œé€²è¡Œé€è¦–æ ¡æ­£
        if (pageContour) {
          // å››å€‹é»æ’åº: å·¦ä¸Šã€å³ä¸Šã€å³ä¸‹ã€å·¦ä¸‹
          let pts = [];
          for (let i = 0; i < 4; i++) {
            pts.push({ x: pageContour.intPtr(i, 0)[0], y: pageContour.intPtr(i, 0)[1] });
          }
          pts.sort((a, b) => a.x + a.y - (b.x + b.y));
          let [tl, br] = [pts[0], pts[3]];
          let [tr, bl] = pts[1].x > pts[2].x ? [pts[1], pts[2]] : [pts[2], pts[1]];

          // å¯¬é«˜
          let widthA = Math.hypot(br.x - bl.x, br.y - bl.y);
          let widthB = Math.hypot(tr.x - tl.x, tr.y - tl.y);
          let maxWidth = Math.max(widthA, widthB);

          let heightA = Math.hypot(tr.x - br.x, tr.y - br.y);
          let heightB = Math.hypot(tl.x - bl.x, tl.y - bl.y);
          let maxHeight = Math.max(heightA, heightB);

          // ä¾†æºé»èˆ‡ç›®æ¨™é»
          let srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
            tl.x, tl.y,
            tr.x, tr.y,
            br.x, br.y,
            bl.x, bl.y
          ]);
          let dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
            0, 0,
            maxWidth - 1, 0,
            maxWidth - 1, maxHeight - 1,
            0, maxHeight - 1
          ]);
          let M = cv.getPerspectiveTransform(srcTri, dstTri);

          // é€è¦–è½‰æ›
          let warped = new cv.Mat();
          cv.warpPerspective(gray, warped, M, new cv.Size(maxWidth, maxHeight), cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());

          // å¼·åŒ–å°æ¯”ï¼ˆäºŒå€¼åŒ–ï¼‰
          cv.adaptiveThreshold(warped, dst, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 19, 9);

          // ç•«å› canvas
          cv.imshow(resultCanvas, dst);

          // æ¸…ç†
          warped.delete(); srcTri.delete(); dstTri.delete(); M.delete();
          pageContour.delete();
        } else {
          // è‹¥æ²’æ‰¾åˆ°æ–‡ä»¶è¼ªå»“ï¼Œç›´æ¥ç°éš+å¼·åŒ–å°æ¯”
          cv.adaptiveThreshold(gray, dst, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 19, 9);
          cv.imshow(resultCanvas, dst);
        }

        // è¼¸å‡º DataURL
        resolve(resultCanvas.toDataURL('image/jpeg', 0.92));

        // é‡‹æ”¾è¨˜æ†¶é«”
        src.delete(); dst.delete(); gray.delete(); blurred.delete(); edged.delete(); contours.delete(); hierarchy.delete();
      });
    }

    async function handleFiles(files) {
      if (!cvReady) {
        alert("OpenCV è¼‰å…¥ä¸­ï¼Œè«‹ç¨å€™å†è©¦ï¼");
        return;
      }
      document.getElementById('loading').style.display = '';
      for (let file of files) {
        if (!file.type.startsWith('image/')) continue;
        await new Promise((resolve) => {
          const reader = new FileReader();
          reader.onload = async e => {
            const img = new Image();
            img.onload = async () => {
              // è™•ç†åœ–ç‰‡
              const processedDataUrl = await processImageAutoCropAndEnhance(img);
              images.push(processedDataUrl);
              updatePreview();
              resolve();
            };
            img.src = e.target.result;
          };
          reader.readAsDataURL(file);
        });
      }
      document.getElementById('loading').style.display = 'none';
    }

    document.getElementById('cameraInput').addEventListener('change', e => {
      handleFiles(e.target.files);
      e.target.value = '';
    });
    document.getElementById('fileInput').addEventListener('change', e => {
      handleFiles(e.target.files);
      e.target.value = '';
    });

    function updatePreview() {
      const preview = document.getElementById('preview');
      preview.innerHTML = '';
      images.forEach((src, i) => {
        const div = document.createElement('div');
        div.className = 'preview-item';
        const img = document.createElement('img');
        img.src = src;
        const btn = document.createElement('button');
        btn.className = 'remove-btn';
        btn.textContent = 'âœ–';
        btn.onclick = () => {
          images.splice(i, 1);
          updatePreview();
        };
        div.appendChild(img);
        div.appendChild(btn);
        preview.appendChild(div);
      });
    }

    function generatePDF() {
      if (images.length === 0) {
        alert('è«‹å…ˆæ–°å¢ç…§ç‰‡');
        return;
      }
      const pdf = new jsPDF({ unit: 'pt', format: 'a4' });
      let first = true;
      images.forEach((src, idx) => {
        const img = new Image();
        img.onload = () => {
          let pdfW = pdf.internal.pageSize.getWidth();
          let pdfH = pdf.internal.pageSize.getHeight();
          let ratio = Math.min(pdfW / img.width, pdfH / img.height);
          let w = img.width * ratio, h = img.height * ratio;
          let x = (pdfW - w) / 2, y = (pdfH - h) / 2;
          if (!first) pdf.addPage();
          pdf.addImage(img, 'JPEG', x, y, w, h);
          if (idx === images.length - 1) {
            pdf.save('document.pdf');
          }
        };
        img.src = src;
        first = false;
      });
    }
  </script>
</body>
</html>
