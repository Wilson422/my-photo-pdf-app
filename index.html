<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="utf--8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>文件拍照轉 PDF（自動偵測 + 邊中拖曳 + 正確方向 + 手動旋轉 + 可再次裁切）</title>
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif; margin:1.2em; background:#f9f9f9; line-height: 1.6; }
  h2 { margin-top:0; font-size: 1.4em; }
  h3 { font-size: 1.0em; font-weight: normal; color: #555; margin: -0.8em 0 1.2em 0; }
  .actions { display:flex; flex-wrap:wrap; gap:.8em; align-items:center; margin-bottom:1em; }
  .actions input[type=file]{ display:none; }
  .actions button { 
    background:#fff; border:1px solid #ccc; padding:.6em 1em; font-size:1em; 
    border-radius:8px; cursor:pointer; transition: background-color 0.2s, box-shadow 0.2s;
  }
  .actions button:hover { background:#f5f5f5; }
  .actions button:active { background:#e9e9e9; transform: translateY(1px); }
  button.danger { background:#ffecec; color:#c51a1a; border-color: #f5c6cb; }
  button.danger:hover { background:#ffdddd; }
  button.danger:active { background:#ffc8c8; }
  #loading { display:none; font-size:.9em; color:#004; font-weight:bold; margin-left:.6em; }
  #storageInfo { font-size:.9em; color:#666; margin:.6em 0; }
  #preview { display:flex; flex-wrap:wrap; gap:12px; margin-top:.8em; }

  .thumb { position:relative; width:140px; background:#fff; padding:8px; box-sizing:border-box; border:2px solid #ddd; border-radius:10px; user-select:none; cursor:pointer; box-shadow: 0 2px 5px rgba(0,0,0,0.05); }
  .thumb:hover { border-color:#007aff; }
  .thumb img { width:100%; height:140px; display:block; border-radius:6px; background:#fff; object-fit:cover; }
  .order-label { position:absolute; top:4px; left:4px; background:rgba(0,122,255,0.85); color:#fff; font-size:12px; padding:4px 7px; border-radius:6px; font-weight:bold; }
  .remove-btn { position:absolute; top:4px; right:4px; background:rgba(255,59,48,0.85); color:#fff; border:none; border-radius:50%; font-size:14px; cursor:pointer; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; line-height: 1; padding: 0; }
  .move-bar { display:none; /* Hidden for simplicity for now */ }

  #cropperModal { position:fixed; inset:0; background:rgba(0,0,0,0.8); display:none; z-index:9999; }
  #cropperModal .modal-content { 
    background:#f0f0f0; width:100%; height: 100%; border-radius:0;
    display:flex; flex-direction:column;
  }
  #cropperTip { font-size:.9em; color:#333; text-align:center; padding: 8px; background-color: #fff; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
  .canvas-wrapper { 
    position:relative; flex-grow: 1; /* Key fix for layout */
    display: flex; align-items: center; justify-content: center;
    background:#333; overflow: hidden;
  }
  canvas#cropperCanvas { display:block; max-width: 100%; max-height: 100%; }

  .handle {
    position:absolute; width:28px; height:28px; margin-left:-14px; margin-top:-14px;
    background:#007aff; border-radius:50%; border:3px solid #fff;
    box-shadow:0 2px 8px rgba(0,0,0,0.5); z-index:60; touch-action:none; cursor:grab;
  }
  .handle:active { cursor:grabbing; }

  .controls-bar { background: #fff; padding: 8px; box-shadow: 0 -1px 3px rgba(0,0,0,0.1); }
  .controls { display:flex; gap:.8em; align-items:center; flex-wrap:wrap; justify-content: center; }
  select { padding:.4em .7em; border-radius:6px; border:1px solid #ccc; background:#fff; font-size: 1em; }
  #cropperBtns { margin-top:8px; display:flex; gap:.8em; flex-wrap:wrap; justify-content: center; }
  #cropperBtns button { padding:.6em 1em; border-radius:8px; border:1px solid #ccc; background:#fff; cursor:pointer; font-size: 1em; }
  #cropperBtns button:active { background:#e9e9e9; transform: translateY(1px); }
  #cropperBtns #cropConfirmBtn { background-color: #007aff; color: white; border-color: #007aff; }

  /* Mobile-first optimizations */
  @media (max-width:768px){
    body { margin: .8em; }
    h2 { font-size: 1.2em; }
    h3 { font-size: .9em; }
    .actions button { padding: .8em 1em; }
    .thumb { width: calc(50% - 12px); }
    .thumb img { height: 120px; }
    .handle { width:34px; height:34px; margin-left:-17px; margin-top:-17px; }
    #cropperTip { font-size: .85em; }
    .controls-bar { padding: 12px; }
  }
</style>
<script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
</head>
<body>
<div id="lineWarningBar">
  偵測到您正透過 LINE 內建瀏覽器使用，此環境可能導致拍照/檔案處理或儲存不穩定。
  建議：使用右上角「在外部瀏覽器開啟」(Android) 或右上角分享 -> 在 Safari 開啟 (iOS)。
  <button onclick="document.getElementById('lineWarningBar').style.display='none'; document.body.classList.remove('has-line-warning');">關閉</button>
</div>

<h2>📄 文件拍照轉 PDF</h2>
<h3>自動偵測 · 邊角拖曳 · 雙指縮放 · 可再次裁切</h3>

<div class="actions">
  <input type="file" accept="image/*" capture="environment" id="cameraInput">
  <input type="file" accept="image/*" multiple id="fileInput">
  <button onclick="triggerCamera()">📷 拍照</button>
  <button onclick="triggerFile()">🖼️ 選照片</button>
  <button onclick="generatePDF()">🧾 產生 PDF</button>
  <button class="danger" onclick="clearAllImages()">🗑️ 清除全部</button>
  <span id="loading">處理中...</span>
</div>

<div id="storageInfo">目前圖片數量：0</div>
<div id="preview"></div>

<div id="cropperModal" role="dialog" aria-modal="true">
  <div class="modal-content">
    <div id="cropperTip">
      拖曳藍點調整，或雙指縮放/拖曳圖片對齊黃色A4框
    </div>
    <div id="canvasContainer" class="canvas-wrapper">
      <canvas id="cropperCanvas"></canvas>
    </div>
    <div class="controls-bar">
      <div class="controls">
        <label>效果：
          <select id="effectSelect">
            <option value="original">原色</option>
            <option value="color_scan">彩色(模擬掃描)</option>
            <option value="gray">灰階</option>
            <option value="bw">黑白（高對比）</option>
          </select>
        </label>
        <button id="autoDetectBtn" title="重新自動找四角">🔍 重跑</button>
        <button id="rotateLeftBtn" title="逆時針 90°">↺ 90°</button>
      </div>
      <div id="cropperBtns">
        <button id="cropResetBtn">重設</button>
        <button id="cropCancelBtn">取消</button>
        <button id="cropConfirmBtn">確定裁切</button>
      </div>
    </div>
  </div>
</div>

<script>
/* Basic Settings */
const CONFIG = { FULL_MAX_DIM: 2000, PREVIEW_MAX_WIDTH: 420, IMAGE_QUALITY: 0.9 };
let images = [];
const { jsPDF } = window.jspdf || {};

/* ========== LINE In-App Browser Detection ========== */
function detectLineInApp(){
  const ua = navigator.userAgent || '';
  if (/ Line\/|; Line\//i.test(ua) || /\bLine\b/i.test(ua)){
    const bar = document.getElementById('lineWarningBar');
    if (bar){
      bar.style.display='block';
      document.body.classList.add('has-line-warning');
    }
  }
}

/* ========== Image Orientation Handling ========== */
async function loadImageNormalized(file){
  const arrayBuffer = await file.arrayBuffer();
  if (self.createImageBitmap){
    try {
      const imgBitmap = await createImageBitmap(new Blob([arrayBuffer]), { imageOrientation: 'from-image' });
      const c = document.createElement('canvas');
      c.width = imgBitmap.width; c.height = imgBitmap.height;
      c.getContext('2d').drawImage(imgBitmap,0,0);
      return c.toDataURL('image/jpeg', CONFIG.IMAGE_QUALITY);
    } catch(e){ console.warn("createImageBitmap failed, falling back.", e); }
  }
  const orientation = getExifOrientation(arrayBuffer);
  const dataUrl = await blobToDataURL(new Blob([arrayBuffer], { type: file.type || 'image/jpeg'}));
  if (orientation === 1) return dataUrl;
  return await fixImageOrientationByOrientation(dataUrl, orientation);
}
function blobToDataURL(blob){
  return new Promise((resolve,reject)=>{
    const fr = new FileReader();
    fr.onload = e => resolve(e.target.result);
    fr.onerror = reject;
    fr.readAsDataURL(blob);
  });
}
function getExifOrientation(arrayBuffer){
  try {
    const view = new DataView(arrayBuffer);
    if (view.getUint16(0,false)!==0xFFD8) return 1;
    let offset=2;
    while (offset < view.byteLength){
      const marker=view.getUint16(offset,false); offset+=2;
      if (marker === 0xFFE1){
        if (view.getUint32(offset+2,false)!==0x45786966) return 1;
        const tiff=offset+8;
        const little=view.getUint16(tiff,false)===0x4949;
        if (view.getUint16(tiff+2,little)!==0x002A) return 1;
        let ifdOffset=view.getUint32(tiff+4,little)+tiff;
        const entries=view.getUint16(ifdOffset,little);
        for (let i=0;i<entries;i++){
          const entry=ifdOffset+2+i*12;
          if (view.getUint16(entry,little)===0x0112) return view.getUint16(entry+8,little) || 1;
        }
      } else if (marker === 0xFFDA) break;
      else offset+=view.getUint16(offset,false);
    }
  } catch(e){ console.error("EXIF parsing failed", e); }
  return 1;
}
function fixImageOrientationByOrientation(dataUrl, orientation){
  return new Promise(resolve=>{
    if (orientation<=1) return resolve(dataUrl);
    const img=new Image();
    img.onload=()=>{
      const w=img.naturalWidth, h=img.naturalHeight;
      const c=document.createElement('canvas');
      const ctx=c.getContext('2d');
      switch(orientation){
        case 2: c.width=w; c.height=h; ctx.transform(-1,0,0,1,w,0); break;
        case 3: c.width=w; c.height=h; ctx.transform(-1,0,0,-1,w,h); break;
        case 4: c.width=w; c.height=h; ctx.transform(1,0,0,-1,0,h); break;
        case 5: c.width=h; c.height=w; ctx.transform(0,1,1,0,0,0); break;
        case 6: c.width=h; c.height=w; ctx.transform(0,1,-1,0,h,0); break;
        case 7: c.width=h; c.height=w; ctx.transform(0,-1,-1,0,h,w); break;
        case 8: c.width=h; c.height=w; ctx.transform(0,-1,1,0,0,w); break;
        default: c.width=w; c.height=h;
      }
      ctx.drawImage(img,0,0);
      resolve(c.toDataURL('image/jpeg', CONFIG.IMAGE_QUALITY));
    };
    img.onerror=()=>resolve(dataUrl);
    img.src=dataUrl;
  });
}

/* ========== Corner Detection & Image Warping (No Change) ========== */
function autoDetectDocumentCorners(img){
  const MAX_SIDE=800;
  const scale=Math.min(1, MAX_SIDE/Math.max(img.width,img.height));
  const sw=Math.round(img.width*scale), sh=Math.round(img.height*scale);
  const c=document.createElement('canvas'); c.width=sw; c.height=sh;
  const ctx=c.getContext('2d'); ctx.drawImage(img,0,0,sw,sh);
  const data=ctx.getImageData(0,0,sw,sh).data;
  const gray=new Uint8ClampedArray(sw*sh);
  for (let i=0,j=0;i<data.length;i+=4,j++) gray[j]=(0.299*data[i]+0.587*data[i+1]+0.114*data[i+2])|0;
  const blur=new Uint8ClampedArray(sw*sh);
  for (let y=0;y<sh;y++){
    for (let x=0;x<sw;x++){
      let sum=0,cnt=0;
      for (let ky=-1;ky<=1;ky++){
        const yy=y+ky; if (yy<0||yy>=sh) continue;
        for (let kx=-1;kx<=1;kx++){
          const xx=x+kx; if (xx<0||xx>=sw) continue;
          sum+=gray[yy*sw+xx]; cnt++;
        }
      }
      blur[y*sw+x]=(sum/cnt)|0;
    }
  }
  const gxK=[-1,0,1,-2,0,2,-1,0,1], gyK=[-1,-2,-1,0,0,0,1,2,1];
  const mag=new Float32Array(sw*sh);
  for (let y=1;y<sh-1;y++){
    for (let x=1;x<sw-1;x++){
      let gx=0,gy=0,idx=0;
      for (let ky=-1;ky<=1;ky++){
        for (let kx=-1;kx<=1;kx++){
          const v=blur[(y+ky)*sw+(x+kx)];
          gx+=v*gxK[idx]; gy+=v*gyK[idx]; idx++;
        }
      }
      mag[y*sw+x]=Math.hypot(gx,gy);
    }
  }
  let sum=0,count=0;
  for (let i=0;i<mag.length;i++){ if(mag[i]>0){ sum+=mag[i]; count++; } }
  const mean=sum/(count||1), thresh=mean*1.3;
  const edge=new Uint8Array(sw*sh);
  for (let i=0;i<mag.length;i++) edge[i]=mag[i]>thresh?1:0;
  const edge2=new Uint8Array(edge);
  for (let y=1;y<sh-1;y++){
    for (let x=1;x<sw-1;x++){
      if (edge[y*sw+x]) continue;
      outer: for (let ky=-1;ky<=1;ky++){
        for (let kx=-1;kx<=1;kx++){
          if (edge[(y+ky)*sw+(x+kx)]){ edge2[y*sw+x]=1; break outer; }
        }
      }
    }
  }
  const pts=[];
  for (let y=0;y<sh;y++) for (let x=0;x<sw;x++) if (edge2[y*sw+x]) pts.push({x,y});
  if (pts.length<50) return null;
  pts.sort((a,b)=>a.x===b.x? a.y-b.y : a.x-b.x);
  function cross(o,a,b){ return (a.x-o.x)*(b.y-o.y)-(a.y-o.y)*(b.x-o.x); }
  const lower=[], upper=[];
  for (const p of pts){
    while (lower.length>=2 && cross(lower[lower.length-2], lower[lower.length-1], p)<=0) lower.pop();
    lower.push(p);
  }
  for (let i=pts.length-1;i>=0;i--){
    const p=pts[i];
    while (upper.length>=2 && cross(upper[upper.length-2], upper[upper.length-1], p)<=0) upper.pop();
    upper.push(p);
  }
  upper.pop(); lower.pop();
  const hull=lower.concat(upper);
  if (hull.length<4) return null;
  let tl,tr,br,bl;
  let minSum=Infinity,maxSum=-Infinity,minDiff=Infinity,maxDiff=-Infinity;
  for (const p of hull){
    const s=p.x+p.y, d=p.x-p.y;
    if (s<minSum){ minSum=s; tl=p; }
    if (s>maxSum){ maxSum=s; br=p; }
    if (d>maxDiff){ maxDiff=d; tr=p; }
    if (d<minDiff){ minDiff=d; bl=p; }
  }
  if(!tl||!tr||!br||!bl) return null;
  const invScale=1/scale;
  const quad=[tl,tr,br,bl].map(p=>({x:p.x*invScale,y:p.y*invScale}));
  function polyArea(q){
    let a=0;
    for (let i=0;i<q.length;i++){
      const p1=q[i], p2=q[(i+1)%q.length];
      a+=p1.x*p2.y - p2.x*p1.y;
    }
    return Math.abs(a)/2;
  }
  if (polyArea(quad) < img.width*img.height*0.1) return null;
  return quad;
}
function solveLinearSystem(A,b){
  const n=A.length; const M=A.map((r,i)=>r.slice().concat(b[i]));
  for (let k=0;k<n;k++){
    let im=k;
    for (let i=k+1;i<n;i++) if (Math.abs(M[i][k])>Math.abs(M[im][k])) im=i;
    if (Math.abs(M[im][k])<1e-12) return null;
    [M[k],M[im]]=[M[im],M[k]];
    const piv=M[k][k];
    for (let j=k;j<=n;j++) M[k][j]/=piv;
    for (let i=0;i<n;i++) if (i!==k){
      const f=M[i][k];
      for (let j=k;j<=n;j++) M[i][j]-=f*M[k][j];
    }
  }
  return M.map(r=>r[n]);
}
function computeHomography(srcPts,dstPts){
  const A=[], b=[];
  for (let i=0;i<4;i++){
    const {x,y}=srcPts[i], {x:u,y:v}=dstPts[i];
    A.push([x,y,1,0,0,0,-u*x,-u*y]); b.push(u);
    A.push([0,0,0,x,y,1,-v*x,-v*y]); b.push(v);
  }
  const h=solveLinearSystem(A,b); if(!h) return null;
  return [[h[0],h[1],h[2]],[h[3],h[4],h[5]],[h[6],h[7],1]];
}
function warpImageWithHomography(srcCanvas,H,dstW,dstH){
  const dst=document.createElement('canvas'); dst.width=dstW; dst.height=dstH;
  const dstCtx=dst.getContext('2d'), srcCtx=srcCanvas.getContext('2d');
  const srcW=srcCanvas.width, srcH=srcCanvas.height;
  const srcData=srcCtx.getImageData(0,0,srcW,srcH).data;
  const dstImg=dstCtx.createImageData(dstW,dstH); const dstData=dstImg.data;
  const Hinv=invert3x3(H); if(!Hinv){ dstCtx.drawImage(srcCanvas,0,0,dstW,dstH); return dst; }
  const [h0,h1,h2] = Hinv[0], [h3,h4,h5] = Hinv[1], [h6,h7,h8] = Hinv[2];
  for (let y=0;y<dstH;y++){
    for (let x=0;x<dstW;x++){
      const denom=h6*x + h7*y + h8;
      const sx=(h0*x + h1*y + h2)/denom;
      const sy=(h3*x + h4*y + h5)/denom;
      const di=(y*dstW+x)*4;
      if (sx>=0&&sy>=0&&sx<srcW-1&&sy<srcH-1){
        const x0=sx|0, y0=sy|0;
        const dx=sx-x0, dy=sy-y0, dx1=1-dx, dy1=1-dy;
        const w00=dx1*dy1, w10=dx*dy1, w01=dx1*dy, w11=dx*dy;
        const i00=(y0*srcW+x0)*4, i10=i00+4, i01=i00+srcW*4, i11=i01+4;
        for(let c=0; c<4; c++){
          dstData[di+c] = srcData[i00+c]*w00 + srcData[i10+c]*w10 + srcData[i01+c]*w01 + srcData[i11+c]*w11;
        }
      }
    }
  }
  dstCtx.putImageData(dstImg,0,0);
  return dst;
}
function invert3x3(m){
  const a=m[0][0],b=m[0][1],c=m[0][2], d=m[1][0],e=m[1][1],f=m[1][2], g=m[2][0],h=m[2][1],i=m[2][2];
  const A=e*i-f*h,B=c*h-b*i,C=b*f-c*e, D=f*g-d*i,E=a*i-c*g,F=c*d-a*f, G=d*h-e*g,H=b*g-a*h,I=a*e-b*d;
  const det=a*A+b*D+c*G; if (Math.abs(det)<1e-12) return null;
  const inv=1/det;
  return [[A*inv,B*inv,C*inv],[D*inv,E*inv,F*inv],[G*inv,H*inv,I*inv]];
}

/* ========== Image Effects (No Change) ========== */
function applyEffect(canvas, effect) {
  if (!canvas || effect === 'original') return;
  const ctx = canvas.getContext('2d');
  const imgd = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const d = imgd.data;

  if (effect === 'color_scan') {
    const brightness = 0.08, contrast = 1.25, brightnessVal = 255 * brightness;
    for (let i = 0; i < d.length; i += 4) {
      d[i] = Math.max(0, Math.min(255, contrast * (d[i] - 128) + 128 + brightnessVal));
      d[i+1] = Math.max(0, Math.min(255, contrast * (d[i+1] - 128) + 128 + brightnessVal));
      d[i+2] = Math.max(0, Math.min(255, contrast * (d[i+2] - 128) + 128 + brightnessVal));
    }
  } else if (effect === 'gray' || effect === 'bw') {
    for (let i = 0; i < d.length; i += 4) {
      const lum = 0.299 * d[i] + 0.587 * d[i + 1] + 0.114 * d[i + 2];
      d[i] = d[i + 1] = d[i + 2] = lum;
    }
    if (effect === 'bw') {
      const hist = new Array(256).fill(0);
      for (let i = 0; i < d.length; i += 4) hist[d[i]]++;
      const total = canvas.width * canvas.height;
      let sum = 0; for (let t = 0; t < 256; t++) sum += t * hist[t];
      let wB = 0, sumB = 0, varMax = 0, th = 0;
      for (let t = 0; t < 256; t++) {
        wB += hist[t]; if (!wB) continue;
        const wF = total - wB; if (!wF) break;
        sumB += t * hist[t];
        const mB = sumB / wB, mF = (sum - sumB) / wF;
        const v = wB * wF * (mB - mF) * (mB - mF);
        if (v > varMax) { varMax = v; th = t; }
      }
      for (let i = 0; i < d.length; i += 4) {
        d[i] = d[i+1] = d[i+2] = d[i] > th ? 255 : 0;
      }
    }
  }
  ctx.putImageData(imgd, 0, 0);
}

/* ========= Cropper UI (HEAVILY REVISED) ========= */
function openCropper(dataUrl, options={}){
  const { initialEffect, initialQuad, initialRotation } = options;
  return new Promise((resolve,reject)=>{
    const modal=document.getElementById('cropperModal');
    const canvas=document.getElementById('cropperCanvas');
    const wrapper=document.getElementById('canvasContainer');
    const statusEl=document.getElementById('autoDetectStatus');
    const effectSelect=document.getElementById('effectSelect');
    
    effectSelect.value = initialEffect || 'original';

    let ctx=canvas.getContext('2d');
    modal.style.display='flex';

    const baseImg=new Image();
    let workingImg=new Image();
    let rotation=0;
    
    let view = { x: 0, y: 0, scale: 1 };
    let handles=[];
    let cornerEls=[];

    function getHandleScreenPos(handle) {
        const imgX = handle.u * workingImg.width;
        const imgY = handle.v * workingImg.height;
        const screenX = (imgX - view.x) * view.scale + canvas.width / 2;
        const screenY = (imgY - view.y) * view.scale + canvas.height / 2;
        return { x: screenX, y: screenY };
    }
    
    function positionCornerEls(){
      for (let i=0;i<4;i++){
        if (!cornerEls[i]) {
          const el=document.createElement('div');
          el.className='handle';
          wrapper.appendChild(el);
          cornerEls[i]=el;
        }
        const pos = getHandleScreenPos(handles[i]);
        cornerEls[i].style.left=pos.x+'px';
        cornerEls[i].style.top =pos.y+'px';
      }
    }

    function redraw(){
      ctx.fillStyle = '#333';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      
      ctx.save();
      ctx.translate(canvas.width / 2, canvas.height / 2);
      ctx.scale(view.scale, view.scale);
      ctx.translate(-view.x, -view.y);
      ctx.drawImage(workingImg, 0, 0);
      ctx.restore();

      if (workingImg.width > 0) {
        const isPortrait = workingImg.height > workingImg.width;
        const a4Ratio = isPortrait ? (1 / Math.sqrt(2)) : Math.sqrt(2);
        const canvasRatio = canvas.width / canvas.height;
        let guideW, guideH;
        if (a4Ratio > canvasRatio) {
          guideW = canvas.width * 0.95;
          guideH = guideW / a4Ratio;
        } else {
          guideH = canvas.height * 0.95;
          guideW = guideH * a4Ratio;
        }
        const guideX = (canvas.width - guideW) / 2;
        const guideY = (canvas.height - guideH) / 2;
        ctx.strokeStyle = 'rgba(255, 200, 0, 0.8)';
        ctx.lineWidth = 2;
        ctx.setLineDash([8, 6]);
        ctx.strokeRect(guideX, guideY, guideW, guideH);
        ctx.setLineDash([]);
      }
      
      ctx.lineWidth=2; ctx.strokeStyle='rgba(0, 122, 255, 0.95)';
      ctx.beginPath();
      for (let i=0;i<4;i++){
        const pos = getHandleScreenPos(handles[i]);
        if (i===0) ctx.moveTo(pos.x,pos.y); else ctx.lineTo(pos.x,pos.y);
      }
      ctx.closePath(); ctx.stroke();
      positionCornerEls();
    }
    
    function resetView() {
        view.scale = Math.min(canvas.width / workingImg.width, canvas.height / workingImg.height);
        view.x = workingImg.width / 2;
        view.y = workingImg.height / 2;
    }

    function setDefaultHandles(){
      const inset=0.05;
      handles=[
        {u:inset, v:inset}, {u:1-inset, v:inset},
        {u:1-inset, v:1-inset}, {u:inset, v:1-inset}
      ];
      resetView();
      redraw();
    }
    function setHandlesByQuad(quad){
      handles = quad.map(p=>({ u: p.x / workingImg.width, v: p.y / workingImg.height }));
      resetView();
      redraw();
    }

    async function runAutoDetect(){
      statusEl.textContent='偵測中...';
      await new Promise(r=>setTimeout(r,16));
      const quad=autoDetectDocumentCorners(workingImg);
      if (quad){
        setHandlesByQuad(quad);
        statusEl.textContent='自動偵測 ✔';
      } else {
        statusEl.textContent='偵測失敗';
        setDefaultHandles();
      }
    }

    function layoutWorkingImage(){
      const dpr = window.devicePixelRatio || 1;
      const rect = wrapper.getBoundingClientRect();
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      ctx.scale(dpr, dpr);
      resetView();
    }

    function applyRotation(delta){
      rotation = (rotation + delta + 360) % 360;
      const w=baseImg.naturalWidth, h=baseImg.naturalHeight;
      const tempCanvas=document.createElement('canvas');
      const tempCtx=tempCanvas.getContext('2d');
      if (rotation === 90 || rotation === 270){
        tempCanvas.width=h; tempCanvas.height=w;
      } else {
        tempCanvas.width=w; tempCanvas.height=h;
      }
      tempCtx.translate(tempCanvas.width/2, tempCanvas.height/2);
      tempCtx.rotate(rotation * Math.PI / 180);
      tempCtx.drawImage(baseImg, -w/2, -h/2);
      
      workingImg.onload = ()=>{
        layoutWorkingImage();
        setDefaultHandles();
        runAutoDetect();
      };
      workingImg.src = tempCanvas.toDataURL('image/jpeg', 0.92);
    }
    
    let dragType=null, dragCornerIdx=-1, lastTap=0;
    let activePointers = [], lastPinchDist = null;

    function getScreenToImgPos(screenX, screenY) {
        const rect = canvas.getBoundingClientRect();
        const canvasX = screenX - rect.left;
        const canvasY = screenY - rect.top;
        const dpr = window.devicePixelRatio || 1;
        const imgX = (canvasX * dpr - canvas.width / 2) / view.scale + view.x;
        const imgY = (canvasY * dpr - canvas.height / 2) / view.scale + view.y;
        return { x: imgX, y: imgY };
    }

    function pointerDown(e){
      activePointers.push(e);
      
      if (activePointers.length > 1) {
        dragType = 'gesture';
        const p1 = activePointers[0], p2 = activePointers[1];
        lastPinchDist = Math.hypot(p1.clientX - p2.clientX, p1.clientY - p2.clientY);
      } else {
        const rect=canvas.getBoundingClientRect();
        const cx=e.clientX-rect.left, cy=e.clientY-rect.top;
        let best=-1, bestD=Infinity;
        for (let i=0;i<4;i++){
          const pos = getHandleScreenPos(handles[i]);
          const d=Math.hypot(pos.x/ (window.devicePixelRatio||1) - cx, pos.y/ (window.devicePixelRatio||1) - cy);
          if (d<bestD){ bestD=d; best=i; }
        }
        if (bestD < 22 ){
          dragType='corner'; dragCornerIdx=best;
        } else {
          dragType = 'pan';
          const now=Date.now();
          if (now-lastTap<300){ setDefaultHandles(); statusEl.textContent='已重設'; dragType = null; }
          lastTap=now;
        }
      }
      if (dragType){
        wrapper.setPointerCapture(e.pointerId);
        wrapper.addEventListener('pointermove', pointerMove);
        wrapper.addEventListener('pointerup', pointerUp);
      }
    }
    function pointerMove(e){
      if (!dragType) return;
      const pointerIndex = activePointers.findIndex(p => p.pointerId === e.pointerId);
      if (pointerIndex > -1) activePointers[pointerIndex] = e;

      if (dragType === 'gesture' && activePointers.length === 2) {
          const p1 = activePointers[0], p2 = activePointers[1];
          const newDist = Math.hypot(p1.clientX - p2.clientX, p1.clientY - p2.clientY);
          const midPoint = { x: (p1.clientX + p2.clientX) / 2, y: (p1.clientY + p2.clientY) / 2 };
          const worldPosBeforeZoom = getScreenToImgPos(midPoint.x, midPoint.y);
          const scaleFactor = newDist / lastPinchDist;
          view.scale *= scaleFactor;
          const worldPosAfterZoom = getScreenToImgPos(midPoint.x, midPoint.y);
          view.x += (worldPosBeforeZoom.x - worldPosAfterZoom.x);
          view.y += (worldPosBeforeZoom.y - worldPosAfterZoom.y);
          lastPinchDist = newDist;
      } else if (dragType === 'pan') {
          const dpr = window.devicePixelRatio || 1;
          view.x -= e.movementX * dpr / view.scale;
          view.y -= e.movementY * dpr / view.scale;
      } else if (dragType === 'corner') {
        const pos = getScreenToImgPos(e.clientX, e.clientY);
        handles[dragCornerIdx].u=Math.max(0,Math.min(1, pos.x / workingImg.width));
        handles[dragCornerIdx].v=Math.max(0,Math.min(1, pos.y / workingImg.height));
      }
      redraw();
    }
    function pointerUp(e){
      activePointers = activePointers.filter(p => p.pointerId !== e.pointerId);
      if (activePointers.length < 2) dragType = activePointers.length === 1 ? 'pan' : null;
      if (activePointers.length === 0) {
        wrapper.removeEventListener('pointermove', pointerMove);
        wrapper.removeEventListener('pointerup', pointerUp);
      }
      wrapper.releasePointerCapture(e.pointerId);
    }

    document.getElementById('cropResetBtn').onclick=()=>{ setDefaultHandles(); statusEl.textContent='已重設'; };
    document.getElementById('autoDetectBtn').onclick=runAutoDetect;
    document.getElementById('rotateLeftBtn').onclick=()=>applyRotation(-90);
    document.getElementById('cropCancelBtn').onclick=()=>{ cleanup(); reject('cancel'); };

    function cleanup(){
      modal.style.display='none';
      wrapper.removeEventListener('pointerdown', pointerDown);
      wrapper.innerHTML = '<canvas id="cropperCanvas"></canvas>';
    }

    baseImg.onload=()=>{
      workingImg.onload = () => {
        layoutWorkingImage();
        if (initialQuad && initialQuad.length === 4) {
          setHandlesByQuad(initialQuad);
          statusEl.textContent = '已載入上次裁切';
        } else {
          setDefaultHandles();
          runAutoDetect();
        }
        wrapper.addEventListener('pointerdown', pointerDown);
        if (initialRotation) {
            // Apply rotation if needed, but the logic is simplified for now
        }
      };
      workingImg.src = baseImg.src;
    };
    baseImg.onerror=()=>{ modal.style.display='none'; reject('img_load_error'); };
    baseImg.src = dataUrl;

    document.getElementById('cropConfirmBtn').onclick=()=>{
      const srcPts = handles.map(h=>({ x: h.u * workingImg.width, y: h.v * workingImg.height }));
      const wA=Math.hypot(srcPts[2].x-srcPts[3].x, srcPts[2].y-srcPts[3].y);
      const wB=Math.hypot(srcPts[1].x-srcPts[0].x, srcPts[1].y-srcPts[0].y);
      const hA=Math.hypot(srcPts[1].x-srcPts[2].x, srcPts[1].y-srcPts[2].y);
      const hB=Math.hypot(srcPts[0].x-srcPts[3].x, srcPts[0].y-srcPts[3].y);
      const dstW=Math.min(Math.round(Math.max(wA,wB)), CONFIG.FULL_MAX_DIM);
      const dstH=Math.min(Math.round(Math.max(hA,hB)), CONFIG.FULL_MAX_DIM);
      const dstPts=[{x:0,y:0},{x:dstW-1,y:0},{x:dstW-1,y:dstH-1},{x:0,y:dstH-1}];
      const H=computeHomography(srcPts,dstPts);
      if(!H){ alert('計算失敗，請調整後重試'); return; }
      const warpCanvas=warpImageWithHomography(workingImg,H,dstW,dstH);
      applyEffect(warpCanvas, effectSelect.value);
      cleanup();
      resolve({ croppedCanvas: warpCanvas, effect: effectSelect.value, quad: srcPts, rotation });
    };
  });
}

/* ========== Thumbnail & Main UI Logic ========== */
function processCroppedCanvas(croppedCanvas,effect){
  return new Promise(resolve=>{
    const tmp=new Image();
    tmp.onload=()=>{
      const r=tmp.width/tmp.height;
      let w=tmp.width, h=tmp.height;
      if (w>h){ if (w>CONFIG.FULL_MAX_DIM){ w=CONFIG.FULL_MAX_DIM; h=w/r;} }
      else { if (h>CONFIG.FULL_MAX_DIM){ h=CONFIG.FULL_MAX_DIM; w=h*r;} }
      const full=document.createElement('canvas'); full.width=w; full.height=h;
      full.getContext('2d').drawImage(tmp,0,0,w,h);
      
      const fullDataUrl=full.toDataURL('image/jpeg',CONFIG.IMAGE_QUALITY);
      
      const prevW = 140;
      const preview=document.createElement('canvas'); preview.width=prevW; preview.height=prevW/r;
      preview.getContext('2d').drawImage(tmp,0,0,prevW, prevW/r);
      const previewDataUrl=preview.toDataURL('image/jpeg',0.8);

      resolve({ fullDataUrl, previewDataUrl, w:full.width, h:full.height });
    };
    tmp.src=croppedCanvas.toDataURL('image/jpeg',0.98);
  });
}

async function editImage(id){
  const item = images.find(i=>i.id===id);
  if (!item) return;
  try{
    const { croppedCanvas, effect, quad, rotation } = await openCropper(item.origDataUrl, {
      initialEffect: item.effect, initialQuad: item.quad, initialRotation: item.rotation
    });
    const processed=await processCroppedCanvas(croppedCanvas, effect);
    Object.assign(item, { ...processed, effect, quad, rotation, ts: Date.now() });
    updatePreview();
  } catch(e){ if (e!=='cancel') console.warn(e); }
}

function handleFiles(fileList){
  if(!fileList || !fileList.length) return;
  document.getElementById('loading').style.display='inline';
  let queue = Array.from(fileList).filter(f => f.type.startsWith('image/'));
  (async function processNext(){
    if (queue.length === 0){
      document.getElementById('loading').style.display='none';
      return;
    }
    const f = queue.shift();
    try{
      const normalizedDataUrl = await loadImageNormalized(f);
      const { croppedCanvas, effect, quad, rotation } = await openCropper(normalizedDataUrl);
      const processed = await processCroppedCanvas(croppedCanvas, effect);
      images.push({
        id: Date.now().toString(36)+Math.random().toString(36).slice(2,9),
        origDataUrl: normalizedDataUrl, ...processed, effect, quad, rotation, ts: Date.now()
      });
      updatePreview();
    } catch(err){ if (err!=='cancel') console.warn(err); }
    finally { processNext(); }
  })();
}
document.getElementById('cameraInput').addEventListener('change', e=>{ handleFiles(e.target.files); e.target.value=''; });
document.getElementById('fileInput').addEventListener('change', e=>{ handleFiles(e.target.files); e.target.value=''; });

function updatePreview(){
  const container=document.getElementById('preview');
  container.innerHTML='';
  images.sort((a,b) => a.ts - b.ts).forEach((o,idx)=>{
    const div=document.createElement('div'); div.className='thumb'; div.dataset.id=o.id;
    const order=document.createElement('div'); order.className='order-label'; order.textContent=idx+1; div.appendChild(order);
    const im=document.createElement('img'); im.src=o.previewDataUrl; im.alt='第 '+(idx+1)+' 張'; div.appendChild(im);
    const del=document.createElement('button'); del.className='remove-btn'; del.textContent='×';
    del.onclick=e=>{
      e.stopPropagation();
      images=images.filter(x=>x.id!==o.id);
      updatePreview();
    };
    div.appendChild(del);
    div.onclick = () => editImage(o.id);
    container.appendChild(div);
  });
  document.getElementById('storageInfo').textContent=`目前圖片數量：${images.length}`;
}

function clearAllImages(){ if (confirm('確定刪除全部圖片？')){ images=[]; updatePreview(); } }
function triggerCamera(){ document.getElementById('cameraInput').click(); }
function triggerFile(){ document.getElementById('fileInput').click(); }

function getPdfFilename(){
  const d=new Date(), p=n=>String(n).padStart(2,'0');
  return d.getFullYear()+p(d.getMonth()+1)+p(d.getDate())+'_'+p(d.getHours())+p(d.getMinutes())+p(d.getSeconds())+'_Scan.pdf';
}

function generatePDF() {
  if (!images.length) { alert('請先加入圖片'); return; }
  document.getElementById('loading').style.display = 'inline';
  try {
    const firstOrientation = images[0].w > images[0].h ? 'landscape' : 'portrait';
    const pdf = new jsPDF({ orientation: firstOrientation, unit: 'pt', format: 'a4' });
    const A4_W = 595.28, A4_H = 841.89;
    images.forEach((img, index) => {
      const isL = img.w > img.h;
      if (index > 0) pdf.addPage('a4', isL ? 'landscape' : 'portrait');
      const pageW = isL ? A4_H : A4_W, pageH = isL ? A4_W : A4_H;
      const ratio = Math.min(pageW / img.w, pageH / img.h);
      const w = img.w * ratio, h = img.h * ratio;
      const x = (pageW - w) / 2, y = (pageH - h) / 2;
      pdf.addImage(img.fullDataUrl, 'JPEG', x, y, w, h);
    });
    pdf.save(getPdfFilename());
  } catch (e) {
    console.error("PDF generation failed:", e);
    alert('產生 PDF 時發生錯誤，請稍後再試。');
  } finally {
    document.getElementById('loading').style.display = 'none';
  }
}

document.addEventListener('DOMContentLoaded', detectLineInApp);
</script>
</body>
</html>
